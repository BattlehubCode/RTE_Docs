{
  "api/Battlehub.RTCommon.IOC.html": {
    "href": "api/Battlehub.RTCommon.IOC.html",
    "title": "Class IOC | Example Unity documentation",
    "keywords": "Class IOC Simple IoC container implementation. Inheritance Object IOC Namespace: Battlehub.RTCommon Assembly: cs.temp.dll.dll Syntax public static class IOC Methods ClearAll() Clears container and removes all registered dependencies and fallbacks Declaration public static void ClearAll() IsFallbackRegistered<T>() Checks if a fallback dependency of type is registered. Declaration public static bool IsFallbackRegistered<T>() Returns Type Description Boolean True if fallback dependency of type with name registered. Type Parameters Name Description T Type of fallback dependency. IsRegistered<T>() Checks if a dependency of type is registered. Declaration public static bool IsRegistered<T>() Returns Type Description Boolean True if dependency of type with name registered. Type Parameters Name Description T Type of dependency. IsRegistered<T>(String) Checks if a named dependency of type is registered. Declaration public static bool IsRegistered<T>(string name) Parameters Type Name Description String name Name of dependency. Returns Type Description Boolean True if dependency of type with name registered. Type Parameters Name Description T Type of dependency. Register<T>(T) Registers dependency of type. Declaration public static void Register<T>(T instance) Parameters Type Name Description T instance Instance of type. Type Parameters Name Description T Type of dependency. Register<T>(Func<T>) Registers dependency of type. Declaration public static void Register<T>(Func<T> func) Parameters Type Name Description Func<T> func Function which constructs object of type. Type Parameters Name Description T Type of dependency. Register<T>(String, T) Registers named dependency of type. Declaration public static void Register<T>(string name, T instance) Parameters Type Name Description String name Name of dependency. T instance Instance of type. Type Parameters Name Description T Type of dependency. Register<T>(String, Func<T>) Registers named dependency of type. Declaration public static void Register<T>(string name, Func<T> func) Parameters Type Name Description String name Name of dependency. Func<T> func Function which constructs object of type. Type Parameters Name Description T Type of dependency. RegisterFallback<T>(T) Registers fallback dependency of type. Declaration public static void RegisterFallback<T>(T instance) Parameters Type Name Description T instance Instance of type. Type Parameters Name Description T Type of fallback dependency. RegisterFallback<T>(Func<T>) Registers fallback dependency of type. Declaration public static void RegisterFallback<T>(Func<T> func) Parameters Type Name Description Func<T> func Function which constructs object of type. Type Parameters Name Description T Type of fallback dependency. Resolve<T>() Resolves dependency or fallback dependency of type. Declaration public static T Resolve<T>() Returns Type Description T Object of type (or null if dependency of type is not registered) Type Parameters Name Description T Type of dependency. Resolve<T>(String) Resolves named dependency or fallback dependency of type. Declaration public static T Resolve<T>(string name) Parameters Type Name Description String name Name of dependency. Returns Type Description T Object of type (or null if dependency of type is not registered) Type Parameters Name Description T Type of dependency. Unregister<T>() Unregisters dependency of type. Declaration public static void Unregister<T>() Type Parameters Name Description T Unregister<T>(T) Unregisters dependency of type. Declaration public static void Unregister<T>(T instance) Parameters Type Name Description T instance Instance which was passed to Register method. Type Parameters Name Description T Type of dependency. Unregister<T>(Func<T>) Unregisters dependency of type. Declaration public static void Unregister<T>(Func<T> func) Parameters Type Name Description Func<T> func Function which was passed to Register method. Type Parameters Name Description T Type of dependency. Unregister<T>(String, T) Unregisters named dependency of type Declaration public static void Unregister<T>(string name, T instance) Parameters Type Name Description String name Name of dependency T instance Instance which was passed to Register method. Type Parameters Name Description T Type of dependency Unregister<T>(String, Func<T>) Unregisters named dependency of type. Declaration public static void Unregister<T>(string name, Func<T> func) Parameters Type Name Description String name Name of dependency. Func<T> func Function which was passed to Register method. Type Parameters Name Description T Type of dependency. UnregisterFallback<T>() Unregisters fallback dependency of type. Declaration public static void UnregisterFallback<T>() Type Parameters Name Description T Type of fallback dependency. UnregisterFallback<T>(T) Unregisters fallback dependency of type. Declaration public static void UnregisterFallback<T>(T instance) Parameters Type Name Description T instance Type Parameters Name Description T Type of fallback dependency. UnregisterFallback<T>(Func<T>) Unregisters fallback dependency of type. Declaration public static void UnregisterFallback<T>(Func<T> func) Parameters Type Name Description Func<T> func Function which was passed to RegisterFallback method. Type Parameters Name Description T Type of fallback dependency."
  },
  "api/Battlehub.RTCommon.html": {
    "href": "api/Battlehub.RTCommon.html",
    "title": "Namespace Battlehub.RTCommon | Example Unity documentation",
    "keywords": "Namespace Battlehub.RTCommon Classes IOC Simple IoC container implementation."
  },
  "api/Battlehub.RTEditor.IWindowManager.html": {
    "href": "api/Battlehub.RTEditor.IWindowManager.html",
    "title": "Interface IWindowManager | Example Unity documentation",
    "keywords": "Interface IWindowManager The window manager allows you to create complex windows, such as an inspector or scene, and simple dialogs, such as a message or confirmation window. The difference between a dialog and a window is quite subtle.The content of a dialog can be anything and it cannot be docked. To be considered a window or dialog box, a RuntimeWindow component must be attached to the game object. When RuntimeWindow is activated, other windows are deactivated. A dialog cannot deactivate a window. Namespace: Battlehub.RTEditor Assembly: cs.temp.dll.dll Syntax public interface IWindowManager Properties ActiveWorkspace IWindowManager can be used to work with multiple workspaces. Declaration Workspace ActiveWorkspace { get; set; } Property Value Type Description Workspace ComponentsRoot The root transform for additional window components. Each window can have one or more additional components that must not have UI Canvas as a parent. Declaration Transform ComponentsRoot { get; } Property Value Type Description Transform DefaultPersistentLayoutName Declaration string DefaultPersistentLayoutName { get; } Property Value Type Description String IsDialogOpened Returns true if dialog opened. Declaration bool IsDialogOpened { get; } Property Value Type Description Boolean PopupRoot Root panel for popups and floating windows. Declaration RectTransform PopupRoot { get; } Property Value Type Description RectTransform Methods ActivateWindow(String) Activates window of type. Declaration bool ActivateWindow(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Returns Type Description Boolean True if the window is activated. ActivateWindow(Transform) Activates window of type. Declaration bool ActivateWindow(Transform content) Parameters Type Name Description Transform content Returns Type Description Boolean True if the window is activated. Confirmation(Sprite, String, String, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, String, String, String) Creates 3 button confirmation dialog. Declaration void Confirmation(Sprite icon, string header, string text, DialogAction<DialogCancelArgs> ok, DialogAction<DialogCancelArgs> cancel, DialogAction<DialogCancelArgs> alt, string okText = \"OK\", string cancelText = \"Cancel\", string altText = \"Close\") Parameters Type Name Description Sprite icon Header icon. String header Header text. String text Message text. DialogAction<DialogCancelArgs> ok Ok action. DialogAction<DialogCancelArgs> cancel Cancel action. DialogAction<DialogCancelArgs> alt Alternative action. String okText Ok button text. String cancelText Cancel button text. String altText Alternative button text. Confirmation(Sprite, String, String, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, String, String) Creates confirmation dialog. Declaration void Confirmation(Sprite icon, string header, string text, DialogAction<DialogCancelArgs> ok, DialogAction<DialogCancelArgs> cancel, string okText = \"OK\", string cancelText = \"Cancel\") Parameters Type Name Description Sprite icon Header icon. String header Header text. String text Mesasge text. DialogAction<DialogCancelArgs> ok Ok action. DialogAction<DialogCancelArgs> cancel Cancel action. String okText Ok button text. String cancelText Cancel button text. Confirmation(String, String, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, String, String, String) Creates 3 button confirmation dialog. Declaration void Confirmation(string header, string text, DialogAction<DialogCancelArgs> ok, DialogAction<DialogCancelArgs> cancel, DialogAction<DialogCancelArgs> alt, string okText = \"OK\", string cancelText = \"Cancel\", string altText = \"Close\") Parameters Type Name Description String header Header text. String text Message text. DialogAction<DialogCancelArgs> ok Ok action. DialogAction<DialogCancelArgs> cancel Cancel action. DialogAction<DialogCancelArgs> alt Alternative action. String okText Ok button text. String cancelText Cancel button text. String altText Alternative button text. Confirmation(String, String, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, String, String) Creates confirmation dialog. Declaration void Confirmation(string header, string text, DialogAction<DialogCancelArgs> ok, DialogAction<DialogCancelArgs> cancel, string okText = \"OK\", string cancelText = \"Cancel\") Parameters Type Name Description String header Header text. String text Message text. DialogAction<DialogCancelArgs> ok Ok action. DialogAction<DialogCancelArgs> cancel Cancel action. String okText Ok button text. String cancelText Cancel button text. CopyTransform(Transform, Transform) Copies source window transform to target window transform. Declaration void CopyTransform(Transform targetConent, Transform sourceContent) Parameters Type Name Description Transform targetConent Target window transform. Transform sourceContent Source window transform. CreateDialogWindow(String, String, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, Boolean, Single, Single) Creates dialog window. Declaration Transform CreateDialogWindow(string windowTypeName, string header, DialogAction<DialogCancelArgs> okAction, DialogAction<DialogCancelArgs> cancelAction, bool canResize, float minWidth = 50F, float minHeight = 50F) Parameters Type Name Description String windowTypeName Window type name. String header Dialog header text. DialogAction<DialogCancelArgs> okAction The action to take when the OK button is clicked. DialogAction<DialogCancelArgs> cancelAction The action to take when the Cancel button is clicked. Boolean canResize True to be able to resize the dialog. Single minWidth Minimum width of the pop-up window. Single minHeight Minimum height of the pop-up window. Returns Type Description Transform CreateDialogWindow(String, String, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, Single, Single, Single, Single, Boolean) Creates dialog window. Declaration Transform CreateDialogWindow(string windowTypeName, string header, DialogAction<DialogCancelArgs> okAction = null, DialogAction<DialogCancelArgs> cancelAction = null, float minWidth = 250F, float minHeight = 250F, float preferredWidth = 700F, float preferredHeight = 400F, bool canResize = true) Parameters Type Name Description String windowTypeName Window type name. String header Dialog header text. DialogAction<DialogCancelArgs> okAction The action to take when the OK button is clicked. DialogAction<DialogCancelArgs> cancelAction he action to take when the Cancel button is clicked. Single minWidth Minimum width of the pop-up window. Single minHeight Minimum height of the pop-up window. Single preferredWidth Perferred width of the pop-up window. Single preferredHeight Perferred height of the pop-up window. Boolean canResize True to be able to resize the dialog. Returns Type Description Transform CreateDropdown(String, RectTransform, Boolean, Single, Single) Creates dropdown window of type. Declaration Transform CreateDropdown(string windowTypeName, RectTransform anchor, bool canResize = false, float minWidth = 10F, float minHeight = 10F) Parameters Type Name Description String windowTypeName Window type name. RectTransform anchor The RectTransform of dropdown anchor. Boolean canResize True to be able to resize the dropdown. Single minWidth Minimum width of the pop-up window. Single minHeight Minimum height of the pop-up window. Returns Type Description Transform CreateLayoutInfo(String) Creates a LayoutInfo object for the window of windowTypeName (creates a window as a side effect). This function and its overrides should be used when creating different \"layouts\". See BuiltInWindowNames for common window type names. Declaration LayoutInfo CreateLayoutInfo(string windowTypeName) Parameters Type Name Description String windowTypeName Type of window to be created Returns Type Description LayoutInfo LayoutInfo. CreateLayoutInfo(String, String) Creates a LayoutInfo object for the window of windowTypeName (creates a window as a side effect). Declaration LayoutInfo CreateLayoutInfo(string windowTypeName, string args) Parameters Type Name Description String windowTypeName Type of window to be created. String args Optional arguments can be obtained using the RuntimeWindow.Args property. Returns Type Description LayoutInfo LayoutInfo. CreateLayoutInfo(Transform, WindowDescriptor) Creates a LayoutInfo object for the window (creates a window as a side effect). Declaration LayoutInfo CreateLayoutInfo(Transform content, WindowDescriptor desc) Parameters Type Name Description Transform content Transform of the window. WindowDescriptor desc Object that describes an icon, a header, a tab and provides information about how many windows of that type can be created. Returns Type Description LayoutInfo LayoutInfo. CreateLayoutInfo(Transform, String, Sprite) Creates a LayoutInfo object for the window (creates a window as a side effect). Declaration LayoutInfo CreateLayoutInfo(Transform content, string header, Sprite icon) Parameters Type Name Description Transform content Transform of the window. String header Header text. Sprite icon Header icon. Returns Type Description LayoutInfo LayoutInfo. CreatePopup(String, Boolean, Single, Single) Creates popup window of type. Declaration Transform CreatePopup(string windowTypeName, bool canResize = false, float minWidth = 10F, float minHeight = 10F) Parameters Type Name Description String windowTypeName Window type name. Boolean canResize True to be able to resize the popup. Single minWidth Minimum width of the pop-up window. Single minHeight Minimum height of the pop-up window. Returns Type Description Transform Transform of the created popup window. CreatePopup(String, Vector2, Boolean, Single, Single) Creates popup window of type Declaration Transform CreatePopup(string windowTypeName, Vector2 position, bool canResize = false, float minWidth = 10F, float minHeight = 10F) Parameters Type Name Description String windowTypeName Window type name. Vector2 position Position in IWindowManager.PopupRoot coordinates. Boolean canResize True to be able to resize the popup. Single minWidth Minimum width of the pop-up window. Single minHeight Minimum height of the pop-up window. Returns Type Description Transform Transform of the created popup window. CreateWindow(String, out WindowDescriptor) Creates window of type (this function is mainly used when creating layouts). Declaration Transform CreateWindow(string windowTypeName, out WindowDescriptor wd) Parameters Type Name Description String windowTypeName Window type name. See BuiltInWindowNames for common window type names. WindowDescriptor wd The descriptor of the created window. Returns Type Description Transform Transform of the created window. CreateWindow(String, out WindowDescriptor, out GameObject, out Boolean) Declaration Transform CreateWindow(string windowTypeName, out WindowDescriptor wd, out GameObject content, out bool isDialog) Parameters Type Name Description String windowTypeName WindowDescriptor wd GameObject content Boolean isDialog Returns Type Description Transform CreateWindow(String, out WindowDescriptor, out Boolean) Creates window of type (this function is mainly used when creating layouts). Declaration Transform CreateWindow(string windowTypeName, out WindowDescriptor wd, out bool isDialog) Parameters Type Name Description String windowTypeName Window type name. See BuiltInWindowNames for common window type names. WindowDescriptor wd The descriptor of the created window. Boolean isDialog True if created window is dialog. Returns Type Description Transform Transform of the created window. CreateWindow(String, Boolean, RegionSplitType, Single, Transform) Creates window of type. Declaration Transform CreateWindow(string windowTypeName, bool isFree = true, RegionSplitType splitType = null, float flexibleSize = 0.3F, Transform parentWindow = null) Parameters Type Name Description String windowTypeName Window type name. Boolean isFree True if windows are to be created in the floating state, and false if in the docked state. RegionSplitType splitType Determines how to dock the window. Single flexibleSize Window size relative to the docked neighbor [0, 1]. Transform parentWindow Transform of the window with which a group of tabs will be formed or which will be the neighbor of the created window. Returns Type Description Transform Transform of the created window. DeleteLayout(String) Declaration void DeleteLayout(string name) Parameters Type Name Description String name DestroyDialogWindow() Destroys the topmost dialog window. Declaration void DestroyDialogWindow() DestroyWindow(Transform) Destroys window. Declaration void DestroyWindow(Transform conent) Parameters Type Name Description Transform conent Transform of the window. DestroyWindowsOfType(String) Destroys window of type. Declaration void DestroyWindowsOfType(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Dialog(Sprite, String, Transform, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, String, String, Single, Single, Single, Single, Boolean) Creates dialog. Declaration void Dialog(Sprite icon, string header, Transform content, DialogAction<DialogCancelArgs> ok, DialogAction<DialogCancelArgs> cancel, string okText = \"OK\", string cancelText = \"Cancel\", float minWidth = 150F, float minHeight = 150F, float preferredWidth = 700F, float preferredHeight = 400F, bool canResize = true) Parameters Type Name Description Sprite icon String header Transform content DialogAction<DialogCancelArgs> ok DialogAction<DialogCancelArgs> cancel String okText String cancelText Single minWidth Single minHeight Single preferredWidth Single preferredHeight Boolean canResize Dialog(Sprite, String, Transform, DialogAction<DialogCancelArgs>, String, DialogAction<DialogCancelArgs>, String, Boolean, Single, Single) Creates dialog. Declaration void Dialog(Sprite icon, string header, Transform content, DialogAction<DialogCancelArgs> ok, string okText = \"OK\", DialogAction<DialogCancelArgs> cancel = null, string cancelText = \"Cancel\", bool canResize = false, float minWidth = 150F, float minHeight = 100F) Parameters Type Name Description Sprite icon Header icon. String header Header text. Transform content Dialog content transform. DialogAction<DialogCancelArgs> ok Ok Action. String okText Ok button text. DialogAction<DialogCancelArgs> cancel Cancel action. String cancelText Cancel button text. Boolean canResize True to be able to resize the dialog. Single minWidth Minimum width of the dialog. Single minHeight Minimum height of the dialog. Dialog(String, Transform, DialogAction<DialogCancelArgs>, DialogAction<DialogCancelArgs>, String, String, Single, Single, Single, Single, Boolean) Creates dialog. Declaration void Dialog(string header, Transform content, DialogAction<DialogCancelArgs> ok, DialogAction<DialogCancelArgs> cancel, string okText = \"OK\", string cancelText = \"Cancel\", float minWidth = 150F, float minHeight = 150F, float preferredWidth = 700F, float preferredHeight = 400F, bool canResize = true) Parameters Type Name Description String header Transform content DialogAction<DialogCancelArgs> ok DialogAction<DialogCancelArgs> cancel String okText String cancelText Single minWidth Single minHeight Single preferredWidth Single preferredHeight Boolean canResize Dialog(String, Transform, DialogAction<DialogCancelArgs>, String, DialogAction<DialogCancelArgs>, String, Boolean, Single, Single) Creates dialog. Declaration void Dialog(string header, Transform content, DialogAction<DialogCancelArgs> ok, string okText = \"OK\", DialogAction<DialogCancelArgs> cancel = null, string cancelText = \"Cancel\", bool canResize = false, float minWidth = 150F, float minHeight = 100F) Parameters Type Name Description String header Header text. Transform content Dialog content transform. DialogAction<DialogCancelArgs> ok Ok Action. String okText Ok button text. DialogAction<DialogCancelArgs> cancel Cancel action. String cancelText Cancel button text. Boolean canResize True to be able to resize the dialog. Single minWidth Minimum width of the dialog. Single minHeight Minimum height of the dialog. Exists(String) Checks if window of type exists. Declaration bool Exists(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Returns Type Description Boolean True if window exists. FindPointerOverWindow(RuntimeWindow) Finds the uppermost window to which pointer is pointing. Declaration Transform FindPointerOverWindow(RuntimeWindow exceptWindow) Parameters Type Name Description RuntimeWindow exceptWindow Except window. Returns Type Description Transform Transform of the uppermost window to which pointer is pointing. ForceLayoutUpdate() Declaration void ForceLayoutUpdate() GetComponents(Transform) Gets extra components associated with the window. Declaration Transform[] GetComponents(Transform content) Parameters Type Name Description Transform content Transform of the window. Returns Type Description Transform[] Array of extra components. GetHeaderIcon(Transform) Gets header icon. Declaration Sprite GetHeaderIcon(Transform content) Parameters Type Name Description Transform content Window transform. Returns Type Description Sprite Header icon. GetHeaderText(Transform) Gets header text of the window. Declaration string GetHeaderText(Transform content) Parameters Type Name Description Transform content Window transform. Returns Type Description String Header text. GetLayout() Creates LayoutInfo object describing current layout. Declaration LayoutInfo GetLayout() Returns Type Description LayoutInfo GetLayout(String, GameObject) Declaration LayoutInfo GetLayout(string name, GameObject tabPrefab = null) Parameters Type Name Description String name GameObject tabPrefab Returns Type Description LayoutInfo GetWindow(String) Gets window transform by type. Declaration Transform GetWindow(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Returns Type Description Transform Window transform. GetWindowDescriptor(String, out Boolean) Gets window descriptor. Declaration WindowDescriptor GetWindowDescriptor(string windowTypeName, out bool isDialog) Parameters Type Name Description String windowTypeName Window type name. Boolean isDialog Is true if the window is a dialog. Returns Type Description WindowDescriptor Window descriptor. GetWindows() Gets transforms of all windows . Declaration Transform[] GetWindows() Returns Type Description Transform[] Array of transforms. GetWindows(String) Gets transfroms of windows of type. Declaration Transform[] GetWindows(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Returns Type Description Transform[] Array of transforms. GetWindowTypeName(Transform) Gets window type name. Declaration string GetWindowTypeName(Transform content) Parameters Type Name Description Transform content Transform of the window. Returns Type Description String Window type name IsActive(String) Checks if the window of this type is in an active state (e.g., if it can receive input). Declaration bool IsActive(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Returns Type Description Boolean True if window is active. IsActive(Transform) Checks if the window in in active state (e.g., if it can receive input). Declaration bool IsActive(Transform content) Parameters Type Name Description Transform content Transform of the window. Returns Type Description Boolean True if window is active. IsWindowRegistered(String) Determines whether a window of the type registered. Declaration bool IsWindowRegistered(string windowTypeName) Parameters Type Name Description String windowTypeName Window type name. Returns Type Description Boolean True if window of type registered. LayoutExist(String) Declaration bool LayoutExist(string name) Parameters Type Name Description String name Returns Type Description Boolean LoadLayout(String, GameObject) Declaration void LoadLayout(string name, GameObject tabPrefab = null) Parameters Type Name Description String name GameObject tabPrefab MessageBox(Sprite, String, String, DialogAction<DialogCancelArgs>) Creates message box. Declaration void MessageBox(Sprite icon, string header, string text, DialogAction<DialogCancelArgs> ok = null) Parameters Type Name Description Sprite icon Header icon. String header Header text. String text Message text. DialogAction<DialogCancelArgs> ok Ok action. MessageBox(String, String, DialogAction<DialogCancelArgs>) Creates message box. Declaration void MessageBox(string header, string text, DialogAction<DialogCancelArgs> ok = null) Parameters Type Name Description String header Header text. String text Message text. DialogAction<DialogCancelArgs> ok Ok action. OverrideDefaultLayout(Func<IWindowManager, LayoutInfo>, String) Overrides default layout builder function. Declaration void OverrideDefaultLayout(Func<IWindowManager, LayoutInfo> layoutBuilderFunc, string activateWindowOfType = null) Parameters Type Name Description Func<IWindowManager, LayoutInfo> layoutBuilderFunc Layout builder function. String activateWindowOfType Type of the window to activate after building layout. OverrideTools(Transform) Overrides header tools (play, pause, pivot mode and various toggles). Declaration void OverrideTools(Transform toolsPrefab) Parameters Type Name Description Transform toolsPrefab Tools prefab transform. OverrideWindow(String, WindowDescriptor) Overrides the WindowDescriptor of a registered window. Declaration void OverrideWindow(string windowTypeName, WindowDescriptor descriptor) Parameters Type Name Description String windowTypeName Window type name. WindowDescriptor descriptor Window descriptor. OverrideWindow(String, GameObject) Overrides the prefab of a registered window. Declaration void OverrideWindow(string windowTypeName, GameObject prefab) Parameters Type Name Description String windowTypeName Window type name. GameObject prefab Prompt(Sprite, String, String, DialogAction<PromptDialogArgs>, DialogAction<PromptDialogArgs>, String, String) Creates prompt dialog. Declaration void Prompt(Sprite icon, string header, string text, DialogAction<PromptDialogArgs> ok, DialogAction<PromptDialogArgs> cancel = null, string okText = \"OK\", string cancelText = \"Cancel\") Parameters Type Name Description Sprite icon Header icon. String header Header text. String text Input field text. DialogAction<PromptDialogArgs> ok Ok action. DialogAction<PromptDialogArgs> cancel Cancel action. String okText Ok button text. String cancelText Cancel button text. Prompt(String, String, DialogAction<PromptDialogArgs>, DialogAction<PromptDialogArgs>, String, String) Creates prompt dialog. Declaration void Prompt(string header, string text, DialogAction<PromptDialogArgs> ok, DialogAction<PromptDialogArgs> cancel = null, string okText = \"OK\", string cancelText = \"Cancel\") Parameters Type Name Description String header Header text. String text Input field text. DialogAction<PromptDialogArgs> ok Ok action. DialogAction<PromptDialogArgs> cancel Cancel action. String okText Ok button text. String cancelText Cancel button text. RegisterWindow(CustomWindowDescriptor) Registers window. Declaration bool RegisterWindow(CustomWindowDescriptor desc) Parameters Type Name Description CustomWindowDescriptor desc Window descriptor. Returns Type Description Boolean True if registration succeeded. SaveLayout(String) Declaration void SaveLayout(string name) Parameters Type Name Description String name ScreenPointToLocalPointInRectangle(RectTransform, Vector3, out Vector2) Transform a screen space point to a position in the local space of a RectTransform that is on the plane of its rectangle. Declaration bool ScreenPointToLocalPointInRectangle(RectTransform rectTransform, Vector3 screenPoint, out Vector2 position) Parameters Type Name Description RectTransform rectTransform The RectTransform to find a point inside. Vector3 screenPoint Screen space position. Vector2 position Point in local space of the rect transform. Returns Type Description Boolean true if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle. SetBottomBar(Transform) Sets bottom bar. Declaration void SetBottomBar(Transform bottomBar) Parameters Type Name Description Transform bottomBar Bottom bar transform. SetDefaultLayout() Rebuilds the layout using the default layout builder function. Declaration void SetDefaultLayout() SetHeaderIcon(Transform, Sprite) Sets header icon. Declaration void SetHeaderIcon(Transform content, Sprite icon) Parameters Type Name Description Transform content Window transform. Sprite icon Header icon. SetHeaderText(Transform, String) Sets header text of the window. Declaration void SetHeaderText(Transform content, string headerText) Parameters Type Name Description Transform content Window transform. String headerText Header text. SetLayout(Func<IWindowManager, LayoutInfo>, String) Builds layout using layout builder function. Declaration void SetLayout(Func<IWindowManager, LayoutInfo> layoutBuilderFunc, string activateWindowOfType = null) Parameters Type Name Description Func<IWindowManager, LayoutInfo> layoutBuilderFunc Layout builder function. String activateWindowOfType Type of the window to activate after building layout. SetLayout(Func<LayoutInfo>, String) Builds layout using layout builder function. Declaration void SetLayout(Func<LayoutInfo> layoutBuilderFunc, string activateWindowOfType = null) Parameters Type Name Description Func<LayoutInfo> layoutBuilderFunc Layout builder function. String activateWindowOfType Type of the window to activate after building layout. SetLeftBar(Transform) Sets left bar. Declaration void SetLeftBar(Transform leftBar) Parameters Type Name Description Transform leftBar Left bar transform. SetRightBar(Transform) Sets right bar. Declaration void SetRightBar(Transform rightBar) Parameters Type Name Description Transform rightBar Right bar transform. SetTools(Transform) Sets header tools. Declaration void SetTools(Transform tools) Parameters Type Name Description Transform tools Content transform. SetTopBar(Transform) Sets top bar. Declaration void SetTopBar(Transform topBar) Parameters Type Name Description Transform topBar Top bar transform. SetTransform(Transform, Vector2, Vector2, Vector2, Vector2) Sets anchoredPosition, anchorMin, anchorMax and size delta. Declaration void SetTransform(Transform content, Vector2 anchoredPosition, Vector2 anchorMin, Vector2 anchorMax, Vector2 sizeDelta) Parameters Type Name Description Transform content Target window transform. Vector2 anchoredPosition Anchored position. Vector2 anchorMin Anchor min. Vector2 anchorMax Anchor max. Vector2 sizeDelta Size delta. SetWindowArgs(Transform, String) Sets window arguments. Declaration void SetWindowArgs(Transform content, string args) Parameters Type Name Description Transform content Transform of the window. String args Arguments. ValidateLayout(LayoutInfo) Validates layout. Declaration bool ValidateLayout(LayoutInfo layout) Parameters Type Name Description LayoutInfo layout LayoutInfo object. Returns Type Description Boolean True if layout is valid. Events AfterLayout Triggers when the layout stage is complete, when all the windows are positioned and ready to use. Declaration event Action<IWindowManager> AfterLayout Event Type Type Description Action<IWindowManager> WindowCreated Triggers after creating a new window. Declaration event Action<Transform> WindowCreated Event Type Type Description Action<Transform> WindowDestroyed Triggers after the window is destroyed. Declaration event Action<Transform> WindowDestroyed Event Type Type Description Action<Transform>"
  },
  "api/Battlehub.RTEditor.html": {
    "href": "api/Battlehub.RTEditor.html",
    "title": "Namespace Battlehub.RTEditor | Example Unity documentation",
    "keywords": "Namespace Battlehub.RTEditor Interfaces IWindowManager The window manager allows you to create complex windows, such as an inspector or scene, and simple dialogs, such as a message or confirmation window. The difference between a dialog and a window is quite subtle.The content of a dialog can be anything and it cannot be docked. To be considered a window or dialog box, a RuntimeWindow component must be attached to the game object. When RuntimeWindow is activated, other windows are deactivated. A dialog cannot deactivate a window."
  },
  "index.html": {
    "href": "index.html",
    "title": "Runtime Editor Docs | Example Unity documentation",
    "keywords": "Runtime Editor Docs Welcome to documentation of Runtime Editor v.3.5.0 the set of scripts and prefabs that will help you to implement scene editor, game level editor or build your own modeling application. If you are new to this documentation please proceed to [introduction] (manual/general.md) page to get an overview what Runtime Editor and this documentation has to offer. Note If you cannot find something in the documentation or have any questions, send an email to Battlehub@outlook.com or ask directly in this support group. Previous Versions: v 2.00 v 2.03 v 2.04 v 2.05 v 2.11 v 2.26 The documentation is organized as following: ##[General] (manual/general.md) [Introduction] (manual/general.md#introduction) List of Features Changelog About Getting Started [Getting Started with Runtime Editor] (manual/runtime-editor.md#getting-started) [Getting Started with Transform Handles] (manual/transform-handles.md#getting-started) [Getting Started with Save & Load] (manual/save-load.md#getting-started) [Expose To Editor] (manual/infrastructure.md#expose-to-editor) [Event methods] (manual/infrastructure.md#event-methods) [IOC] (manual/infrastructure.md#ioc) [Runtime Selection] (manual/infrastructure.md#runtime-selection) [Runtime Undo] (manual/infrastructure.md#runtime-undo) [Transform Handles] (manual/transform-handles.md) [Overview] (manual/transform-handles.md#overview) [Getting Started] (manual/transform-handles.md#getting-started) [Base Handle] (manual/transform-handles.md#base-handle) [Position Handle] (manual/transform-handles.md#position-handle) [Rotation Handle] (manual/transform-handles.md#rotation-handle) [Scale Handle] (manual/transform-handles.md#scale-handle) [Rect Tool] (manual/transform-handles.md#rect-tool) [Locking Axes] (manual/transform-handles.md#locking-axes) [Scene Gizmo] (manual/transform-handles.md#scene-gizmo) [Grid] (manual/transform-handles.md#grid) [Runtime Handles Component] (manual/transform-handles.md#runtime-handles-component) [Runtime Selection Component] (manual/transform-handles.md#runtime-selection-component) [Box Selection] (manual/transform-handles.md#box-selection) [Runtime Scene Component] (manual/transform-handles.md#runtime-scene-component) [Common Infrastructure] (manual/infrastructure.md) [Overview] (manual/infrastructure.md#overview) [Expose To Editor] (manual/infrastructure.md#expose-to-editor) [Event methods] (manual/infrastructure.md#event-methods) [IOC] (manual/infrastructure.md#ioc) [IRTE interface] (manual/infrastructure.md#irte-interface) [Input] (manual/infrastructure.md#input) [RTE Component] (manual/infrastructure.md#rte-component) [Runtime Selection] (manual/infrastructure.md#runtime-selection) [Runtime Objects] (manual/infrastructure.md#runtime-objects) [Runtime Tools] (manual/infrastructure.md#runtime-tools) [Runtime Undo] (manual/infrastructure.md#runtime-undo) [Drag And Drop] (manual/infrastructure.md#drag-and-drop) [Runtime Window] (manual/infrastructure.md#runtime-window) [Runtime Editor] (manual/runtime-editor.md) [Overview] (manual/runtime-editor.md#overview) [Getting Started] (manual/runtime-editor.md#getting-started) [Main & Context Menu] (manual/runtime-editor.md#main--context-menu) [RTEDeps] (manual/runtime-editor.md#rtedeps) [Window Manager] (manual/runtime-editor.md#window-manager) [How To: How to add custom window to Window Manager] (manual/runtime-editor.md#how-to-add-custom-window-to-window-manager) [How to: override default layout] (manual/runtime-editor.md#how-to-override-default-layout) [How to: override scene parameters] (manual/runtime-editor.md#how-to-override-scene-parameters) [How to: override tools panels] (manual/runtime-editor.md#how-to-override-tools-panel) [How to: override ui scale] (manual/runtime-editor.md#how-to-override-ui-scale) [How to: change runtime editor colors] (manual/runtime-editor.md#how-to-change-runtime-editor-colors) [File Importers] (manual/runtime-editor.md#file-importers) [Inspector View] (manual/runtime-editor.md#inspector-view) [How To: Configure Editors] (manual/runtime-editor.md#how-to-configure-editors) [How To: Select Component Properties] (manual/runtime-editor.md#how-to-select-component-properties) [Resource Preview Utility] (manual/runtime-editor.md#resource-preview-utility) [Save Load] (manual/save-load.md) [Overview] (manual/save-load.md#overview) [Getting Started] (manual/save-load.md#getting-started) [Persistent Classes] (manual/save-load.md#persistent-classes) [How To: Create Custom Persistent Class] (manual/save-load.md#how-to-create-custom-persistent-class) [Asset Library] (manual/save-load.md#asset-library) [How To: Create Asset Library] (manual/save-load.md#how-to-create-asset-library) [Project Item & Asset Item] (manual/save-load.md#project-item--asset-item) [Project] (manual/save-load.md#project) [Rendering] (manual/rendering.md) [IRTECamera] (manual/rendering.md#irtecamera) [Graphics Layer Camera] (manual/rendering.md#graphics-layer-camera) [Gizmos] (manual/gizmos.md) [Overview] (manual/gizmos.md#overview) [Getting Started With Gizmos] (manual/gizmos.md#getting-started) [Base Gizmo] (manual/gizmos.md#base-gizmo) [Box Gizmo] (manual/gizmos.md#box-gizmo) [Sphere Gizmo] (manual/gizmos.md#sphere-gizmo) [Capsule Gizmo] (manual/gizmos.md#capsule-gizmo) [Cone Gizmo] (manual/gizmos.md#cone-gizmo) [Box Collider Gizmo] (manual/gizmos.md#box-collider-gizmo) [Sphere Collider Gizmo] (manual/gizmos.md#sphere-collider-gizmo) [Capsule Collider Gizmo] (manual/gizmos.md#capsule-collider-gizmo) [Point Light Gizmo] (manual/gizmos.md#point-light-gizmo) [Spot Light Gizmo] (manual/gizmos.md#spot-light-gizmo) [Directional Light Gizmo] (manual/gizmos.md#directional-light-gizmo) [Audio Source Gizmo] (manual/gizmos.md#audio-source-gizmo) [Audio Reverb Zone Gizmo] (manual/gizmos.md#audio-reverb-zone-gizmo) [Skinned Mesh Renderer Gizmo] (manual/gizmos.md#skinned-mesh-renderer-gizmo) [Dock Panel] (manual/dock-panels.md) [Overview] (manual/dock-panels.md#overview) [Getting Started] (manual/dock-panels.md#getting-started) [Dock Panel] (manual/dock-panels.md#dock-panel) [Tab] (manual/dock-panels.md#tab) [Region] (manual/dock-panels.md#region) [Dialog Manager] (manual/dock-panels.md#dialog-manager) [Virtualizing TreeView] (manual/vtv.md) [Overview] (manual/vtv.md#overview) [Getting Started] (manual/vtv.md#getting-started) [Virtualizing Scroll Rect] (manual/vtv.md#virtualizing-scroll-rect) [Virtualizing Items Control] (manual/vtv.md#virtualizing-items-control) [Virtualizing Drop Marker] (manual/vtv.md#virtualizing-drop-marker) [Virtualizing Tree View] (manual/vtv.md#virtualizing-tree-view) [Virtualizing Tree View Item] (manual/vtv.md#virtualizing-tree-view-item) [Menu Control] (manual/menu-control.md) [Overview] (manual/menu-control.md#overview) [Getting Started] (manual/menu-control.md#getting-started) [Menu Item] (manual/menu-control.md#menu-item) [Menu] (manual/menu-control.md#menu) [Main Menu Button] (manual/menu-control.md#main-menu-button) [Context Menu Trigger] (manual/menu-control.md#context-menu-trigger) ##[Animation Editor] (manual/animation-editor.md) [Overview] (manual/animation-editor.md#overview) ##[Editor Extensions] (manual/editor-extensions.md) [Overview] (manual/editor-extensions.md#overview) [Getting Started] (manual/editor-extensions.md#getting-started) [Editor Extensions] (manual/editor-extensions.md#editor-extensions) [Runtime Builder] (manual/editor-extensions.md#runtime-builder) [Terrain Editor] (manual/editor-extensions.md#terrain-editor) [Runtime Scripting] (manual/editor-extensions.md#runtime-scripting) ##[Universal RP Support] (manual/urp-support.md) [Overview] (manual/urp-support.md#overview) [Getting Started] (manual/urp-support.md#getting-started) ##[HDRP Support] (manual/hdrp-support.md) [Overview] (manual/hdrp-support.md#overview) [Getting Started] (manual/hdrp-support.md#getting-started)"
  },
  "manual/animation-editor.html": {
    "href": "manual/animation-editor.html",
    "title": "| Example Unity documentation",
    "keywords": "#Animation Editor Docs ##Overview The Animation Editor adds to the Runtime Editor the ability to create and edit animations. Animation Editor Prefabs can be found in Assets\\Battlehub\\RTEditor\\Content\\Runtime\\RTEditor\\Prefabs. This is example on how to create RuntimeAnimation: using Battlehub.RTCommon; using Battlehub.UIControls.MenuControl; using System.Collections.Generic; using UnityEngine; namespace Battlehub.RTEditor.Examples.Scene90 { /* Property names can be looked up by setting Asset Serialization to Force Text mode in the Editor settings. The text files that are then written by the editor will include the names of the properties. For example, the yaml file written for a Scene object will include the Camera settings. Looking at this yaml file will show: m_BackGroundColor: {r: .192156866, g: .301960796, b: .474509805, a: .0196078438} m_NormalizedViewPortRect: serializedVersion: 2 x: 0 y: 0 width: 1 height: 1 near clip plane: .300000012 far clip plane: 1000 field of view: 60 orthographic: 0 orthographic size: 5 m_Depth: -1 This shows that the name for the FOV parameter is \"field of view\". If you wanted to create an animation clip to animate the camera field of view, you would pass \"field of view\" as the propertyName. */ [MenuDefinition] public class AnimationEditorExampleMenu : MonoBehaviour { [MenuCommand(\"Example/Create Runtime Animation\")] public void CreateRuntimeAnimation() { GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube); go.AddComponent<ExposeToEditor>(); RuntimeAnimationClip clip = ScriptableObject.CreateInstance<RuntimeAnimationClip>(); RuntimeAnimationProperty property = new RuntimeAnimationProperty(); property.Component = go.GetComponent<Transform>(); property.ComponentTypeName = \"UnityEngine.Transform, UnityEngine.CoreModule\"; property.ComponentDisplayName = \"Transform\"; property.AnimationPropertyName = \"m_LocalPosition\"; property.PropertyDisplayName = \"Position\"; property.PropertyName = \"localPosition\"; property.Children = new List<RuntimeAnimationProperty> { new RuntimeAnimationProperty { Parent = property, Component = property.Component, ComponentTypeName = property.ComponentTypeName, PropertyDisplayName = \"x\", PropertyName = \"x\", Curve = new AnimationCurve { keys = new[] { new Keyframe(0, go.transform.position.x), new Keyframe(0.5f, go.transform.position.x), new Keyframe(1, go.transform.position.x), } } }, new RuntimeAnimationProperty { Parent = property, Component = property.Component, ComponentTypeName = property.ComponentTypeName, PropertyDisplayName = \"y\", PropertyName = \"y\", Curve = new AnimationCurve { keys = new[] { new Keyframe(0, go.transform.position.y), new Keyframe(0.5f, go.transform.position.y + 3.0f), new Keyframe(1, go.transform.position.y), } } }, new RuntimeAnimationProperty { Parent = property, Component = property.Component, ComponentTypeName = property.ComponentTypeName, PropertyDisplayName = \"z\", PropertyName = \"z\", Curve = new AnimationCurve { keys = new[] { new Keyframe(0, go.transform.position.z), new Keyframe(0.5f, go.transform.position.z), new Keyframe(1, go.transform.position.z), } } } }; clip.Add(property); RuntimeAnimation animation = go.AddComponent<RuntimeAnimation>(); animation.Clips = new List<RuntimeAnimationClip> { clip }; IRTE rte = IOC.Resolve<IRTE>(); rte.Selection.activeGameObject = go; } } }"
  },
  "manual/dock-panels.html": {
    "href": "manual/dock-panels.html",
    "title": "Dock Panel Docs | Example Unity documentation",
    "keywords": "Dock Panel Docs Overview The Dock Panel is a control, that provides an easy docking of content regions to the left, right, top, bottom or center of the panel. The control also allow region to become an independent floating window, modal popup or dialog. ##Getting Started Create Canvas. Add DockPanel.prefab from Assets/Battlehub/RTEditor/Content/Runtime/UIControls/DockPanels/Prefabs to hierarchy. Create GettingStarted.cs script and add it to DockPanel Game Object. Hit Play. using Battlehub.UIControls.DockPanels; using UnityEngine; using UnityEngine.UI; public class GettingStarted : MonoBehaviour { DockPanel m_dockPanel; void Start() { m_dockPanel = GetComponent<DockPanel>(); GameObject testContent = new GameObject(); testContent.AddComponent<Image>().color = new Color(0.2f, 0.2f, 0.2f, 1.0f); LayoutInfo layout = new LayoutInfo(false, new LayoutInfo(testContent.transform, \"Tab 1\"), new LayoutInfo( isVertical: true, child0: new LayoutInfo(Instantiate(testContent).transform, \"Tab 2\"), child1: new LayoutInfo(Instantiate(testContent).transform, \"Tab 3\"), ratio: 0.5f), 0.5f); m_dockPanel.RootRegion.Build(layout); } } Note Full demo can be found in Assets/Battlehub/RTEditorDemo/Content/Runtime/UIControls/DockPanels folder ##Dock Panel Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/DockPanels/Prefabs/DockPanel.prefab Script: /Battlehub/RTEditor/Runtime/UIControls/DockPanels/DockPanel.cs Fields: Mask - masking everything outside of DockPanel (image with Rect2D Component) Docked - parent for docked regions Free - parent for floating regions Preview - parent for tab preview visible during tab re-parenting operation. Modal - parent for modal pop-ups and dialogs. Region Prefab - reference to region prefab. Tab Prefab - reference to default tab prefab. ##Tab Default Style: Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/DockPanels/Prefabs/Tab.prefab Script: /Battlehub/RTEditor/Runtime/UIControls/DockPanels/Tab.cs Fields: Canvas Group - required to hide tab but preserve occupied space during rearrangements. Img - tab icon. Text - tab header text. Close Button - tab close button. Toggle - reference to toggle control (tab have 2 states 'selected' and 'unselected'). ##Region Default Style: Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/DockPanels/Prefabs/Region.prefab Script: /Battlehub/RTEditor/Runtime/UIControls/DockPanels/Region.cs Fields: Maximize Toggle - expands owner region and hide others. Can Resize - enables/disable ability to resize region. Layout Element - reference to root Layout Element. Tab Panel - panel for tabs. Content Panel - panel for content. Children Panel - panel for child regions. Root - reference to dock panel. Header Image - region header graphics. Frame Image - region content frame graphics. Methods: void Build(LayoutInfo layoutInfo) - build layout. GameObject content1 = new GameObject(); content1.AddComponent<Image>().color = Color.red; GameObject content2 = new GameObject(); content2.AddComponent<Image>().color = Color.yellow; m_region.Build(new LayoutInfo( isVertical: false, child0: new LayoutInfo(content1.transform, \"Header 1\"), child1: new LayoutInfo(content2.transform, \"Header 2\"), ratio: 0.25f)); void RemoveAt(int index) - remove content at index. void Add(Sprite icon, string header, Transform content, bool isFree = false, RegionSplitType splitType = RegionSplitType.None) - add content to region. Sprite icon = null; GameObject content = new GameObject(); content.AddComponent<Image>().color = Color.green; //1. Add content m_region.Add(icon, \"Header1\", content.transform, false, RegionSplitType.None); //2. Add content to the left m_region.Add(icon, \"Header2\", content.transform, false, RegionSplitType.Left); //3. Add content to the right m_region.Add(icon, \"Header3\", content.transform, false, RegionSplitType.Right); //4. Add content on the top m_region.Add(icon, \"Header4\", content.transform, false, RegionSplitType.Top); //5. Add content to the bottom m_region.Add(icon, \"Header5\", content.transform, false, RegionSplitType.Bottom); //6. Add content to floating region m_region.Add(icon, \"Tab 3\", content.transform, true); ##Dialog Manager Dialog manager allows you to create various dialogs and pop-ups. Dialogs are created as a modal floating regions of dock panel. To use dialog manager do following: Add Assets/Battlehub/RTEditor/Runtime/UIControls/Dialog/DialogManager component. Set Dock Panel field. Set Dialog field to Assets/Battlehub/RTEditor/Content/Runtime/UIControls/Dialog/Prefabs/Dialog.prefab. using Battlehub.UIControls.Dialogs; using UnityEngine; using UnityEngine.UI; public class DialogManagerExamples : MonoBehaviour { [SerializeField] DialogManager m_dialogManager; [SerializeField] Sprite m_icon; void Start() { //Show message box with \"OK\" button m_dialogManager.ShowDialog(m_icon, \"Message Header\", \"Message Text\"); //Show confirmation with \"Yes\" and \"No\" buttons m_dialogManager.ShowDialog(m_icon, \"Scene has been modified\", \"Do you want to save changed you made in the scene?\", (dialog, cancelArgs) => { Debug.Log(\"Yes clicked\"); }, \"Yes\", (dialog, cancelArgs) => { Debug.Log(\"No clicked\"); }, \"No\"); //Show popup with custom content GameObject content = new GameObject(); content.AddComponent<Image>().color = Color.red; m_dialogManager.ShowDialog(m_icon, \"Popup\", content.transform); } }"
  },
  "manual/editor-extensions.html": {
    "href": "manual/editor-extensions.html",
    "title": "| Example Unity documentation",
    "keywords": "#Editor Extensions Docs ##Overview Editor Extensions are additional functionality that can be used optionally with the Runtime Editor. At the moment there are three built-in editor extensions: Runtime Builder - integration and user interface for Unity ProBuilder. Terrain Editor - user interface and additional functionality for Terrain editing Runtime Scripting - ability to create and compile MonoBehavior scripts at runtime ##Getting Started To start working with the editor extensions perform the following steps: Create Runtime Editor using Tools->Runtime Editor->Create Editor. Create Editor Extensions using Tools->Runtime Editor->Create Extensions. Hit Play. Editor extensions should be available from the Window menu item. ##Editor Extensions Editor extensions are located in Assets/Battlehub/RTExtensions folder. The /Content folder contains resources and prefabs, the /Runtime folder contains runtime scripts, and the /Editor folder contains scripts that run in the Unity editor. The prefab that initializes all extensions is called EditorExtensions and is located in the /RTExtensions/Content/Runtime folder. ##Runtime Builder The Runtime Builder extension allows you to create and edit meshes, prototype, edit game object materials and texture UVs in Runtime Editor using Unity ProBuilder. RTBuilder prefab can be found in /Battlehub/RTExtensions/Content/Runtime/RTBuilder. Standalone RTBuilder demo scene can be found in: /Battlehub/RTEditorDemo/Content/Runtime/RTExtensions/RTBuilder ##Terrain Editor The Terrain Editor extension allows you to add to Runtime Editor the possibility of editing Terrain objects. RTTerrain prefab can be found in __/Battlehub/RTExtensions/Content/Runtime/RTTerrain folder. ##Runtime Scripting The Runtime Scripting extension allows you to create C# scripts at run-time using the Runtime Editor. The RTScripting prefab that initializes the extension can be found at /Battlehub/RTScripting/Content/Runtime. Note Unpack RTScripting and RTScripting Demo packages: Note Runtime Scripting Extension is only supported in a Standalone Windows build Note Runtime Scripting Extension use Roslyn.net compiler platform After adding the RTScripting prefab to the scene, the Create->Script context menu item becomes available. The script editor can be opened using the context menu or by double-clicking the script icon. For programmatic access to the RTScripting extension you need to use the IRuntimeScriptManager interface. Here is how to add references to additional assemblies: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.RTScripting; using UnityEngine.AI; public class AddReferencesExample : EditorExtension { protected override void OnEditorExist() { base.OnEditorExist(); IRuntimeScriptManager scriptManager = IOC.Resolve<IRuntimeScriptManager>(); scriptManager.AddReference(typeof(NavMesh).Assembly.Location); } } Example on how to create and compile script at runtime: using Battlehub.RTCommon; using Battlehub.RTScripting; using Battlehub.RTSL.Interface; using Battlehub.UIControls.MenuControl; using System; using System.Threading.Tasks; using UnityEngine; namespace Battlehub.RTEditor.Examples.Scene60 { [MenuDefinition] public class RuntimeScriptingExampleMenu : MonoBehaviour { private static string s_nl = Environment.NewLine; private static string s_csTemplate = \"using System.Collections;\" + s_nl + \"using System.Collections.Generic;\" + s_nl + \"using UnityEngine;\" + s_nl + s_nl + \"public class {0} : MonoBehaviour\" + s_nl + \"{{\" + s_nl + \" // Start is called before the first frame update\" + s_nl + \" void Start()\" + s_nl + \" {{\" + s_nl + \" {1}\" + s_nl + \" }}\" + s_nl + s_nl + \" // Update is called once per frame\" + s_nl + \" void Update()\" + s_nl + \" {{\" + s_nl + \" {2}\" + s_nl + \" }}\" + s_nl + s_nl + \" void OnRuntimeEditorOpened()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Editor Opened\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \" void OnRuntimeEditorClosed()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Editor Closed\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \" void RuntimeAwake()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Awake in play mode\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \" void RuntimeStart()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Start in play mode\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \" void OnRuntimeDestroy()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Destroy in play mode\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \" void OnRuntimeActivate()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Game view activated\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \" void OnRuntimeDeactivate()\" + s_nl + \" {{\" + s_nl + \" Debug.Log(\\\"Game view deactivated\\\");\" + s_nl + \" }}\" + s_nl + s_nl + \"}}\"; [MenuCommand(\"Example/Create Script\")] public async void CreateScript() { IProjectAsync project = IOC.Resolve<IProjectAsync>(); IRuntimeScriptManager scriptManager = IOC.Resolve<IRuntimeScriptManager>(); string desiredTypeName = \"MyHelloWorld\"; ProjectItem assetItem = await scriptManager.CreateScriptAsync( project.State.RootFolder, desiredTypeName); RuntimeTextAsset cs = await scriptManager.LoadScriptAsync(assetItem); string typeName = cs.name; cs.Text = string.Format(s_csTemplate, typeName, \"Debug.Log(\\\"Hello World\\\");\", \" \", \"\"); await scriptManager.SaveScriptAsync(assetItem, cs); await scriptManager.CompileAsync(); GameObject testGo = new GameObject(\"RT Scripting example\"); testGo.AddComponent<ExposeToEditor>(); testGo.AddComponent(scriptManager.GetType(typeName)); await Task.Yield(); IRTE editor = IOC.Resolve<IRTE>(); editor.IsPlaying = true; await Task.Yield(); editor.IsPlaying = false; } } }"
  },
  "manual/general.html": {
    "href": "manual/general.html",
    "title": "| Example Unity documentation",
    "keywords": "#Introduction This documentation covers most important parts of Runtime Editor. Unlike previous versions of the documentation, I tried to concentrate more on examples rather then documenting each property of each script. Let me know what examples you would like to see. Start with following sections: Getting Started with Runtime Editor Getting Started with Transform Handles Getting Started with Save & Load Expose To Editor Event methods IOC Runtime Selection Runtime Undo ##List of Features Position Handle, Rotation Handle, Scale Handle, Rect Tool. Grid, Box Selection, Scene Gizmo. Global & Local coordinates, Local & Center pivot point modes, Vertex & Grid snapping. Gizmos for Colliders, Lights and Audio Sources. Scene navigation, Orthographic & Perspective mode. Undo & Redo API. Object selection API. Object life-cycle Events. Play & Edit mode. Configurable Inspector. Component & Material editors. 20+ Built-in property editors. Ability to edit components of multiple selected objects. Add Component control. Multiple scenes and cameras support. Dock Panels & Windows Management. Dialogs, Message Boxes, Confirmations. Easy to extend with new windows. Configurable Main & Context menu. Lightweight Virtualizing Tree View for Hierarchy and Project windows. Configurable Save & Load subsystem (almost no coding is required). Easy to use Project API. Static Assets, Asset Bundles and Runtime Assets support. Load assets on demand. Multiple Projects support. Animation Editor. Terrain Editor. ProBuilder Integration. Runtime Scripting. Universal Render Pipeline support. HD Renderer Pipeline support (Beta). Mobile Support. ###Breaking Changes Old Views derived from RuntimeWindow are replaced with Views and ViewModels and MVVM-style data-binding system for Unity. Old views and dialogs have been moved to the Battlehub/RTEditor/Runtime/RTEditor/Legacy folder. Old prefabs can be found in the Battlehub/RTEditor/Content/Runtime/RTEditor/Prefabs/Legacy folder. New Views and ViewModels are located in Battlehub/RTEditor/Runtime/RTEditor/Views and Assets/Battlehub/RTEditor/Runtime/RTEditor/ViewsModels respectively. If you want to use legacy built-in windows, select the \"Use Legacy Built-In Windows\" toggle in the WindowManager component of the RuntimEditor prefab. ##Changelog ####RTE 3.5.0 - Dec 24, 2021 RTE: SceneViewImpl, SceneViewModel ExposePrefabInstance modified to not expose full hierarchy. UI: Set VirtualizingListBoxItem.m_toggle.interactable to true by default UI: Added VirtualizingScrollRect.ItemsChanged event UI: Added VirtualizingListBoxBinding.CanRemove property UI: Added VirtualizingListBoxBinding.CanReorder property UI: Added VirtualizingListBoxBinding.CanSelect property UI: Added VirtualizingListBoxBinding.Target property UI: Changed VirtualizingListBoxBinding base class from AbstractMemberBinding to ControlBinding RTE: Added code to activate Dialog windows WindowManager.OnInputModuleUpdate() RTE: Added WindowOverlay to RuntimeEditor.prefab \\UI\\LayoutRoot\\Middle\\DockPanels\\Mask\\Modal RTE PeekMode: added Commands Panel RTE PeekMode: added Group, Ungroup, CreatePrefab buttons to GameObjectView RTE PeekMode: added \"Begin Create\" button RTE: Added Tools/Runtime Editor/Create Custom Window menu command RTE: Added ability to Create CustomView and CustomViewModel from template RTE: UnityWeld.dll Auto Reference flag set to True RTH: Added code to update ExposeToEditor.LocalEulerAngles from RotationHandle RTE: Added support for Rotations > 360 degrees in Animation Editor RTE: Fixed AnimationViewModel undo & redo RTE: Fixed Legacy AnimationView undo & redo RTE: Added InspectorModel RTC: Deprecated RuntimeTools.ShowGizmos, ShowGizmosChanged, ShowSelectionGizmos, ShowSelectionGizmosChanged RTC: IOC.IsRegistered and IOC.IsFallbackRegistered methods added RTE: Models\\Placement\\PlacementModel added to RuntimeEditor.prefab RTE: Models\\Grouping\\GroupingModel added to RuntimeEditor.prefab RTE: Deprecated IRuntimEditorExt RTE: Added IPlacementModel, PlacementModel RTE: Added IGroupingModel, GroupingModel RTE PeekMode: Added PeekModeCommandsHandler RTE PeekMode: Added CreatorWindow RTE: Added Transform IWindowManager.Prompt(string header, string text, DialogAction ok, DialogAction cancel, string okText = \"OK\", string cancelText = \"Cancel\") RTE: Added Transform IWindowManager.Prompt(Sprite icon, string header, string text, DialogAction ok, DialogAction cancel, string okText = \"OK\", string cancelText = \"Cancel\") RTE: Added EmptyView and EmptyDialog RTE: Added AutoUI RTE: added IProjectTreeViewModel, IProjectFolderViewModel as replacement for IProjectTree and IProjectFolder RTC: Added IRuntimeObjects.ComponentDestroyed event RTC: Added ExposeToEditor._ComponentDestroyed event RTE: IWindowManager.CreatePopup, .CreateDropdown methods added UI: Added RaiseTransformChanged() call to Start method of RectTransformChangeListener (in order to correctly initialize VirtualizingScrollRect) UI: Added Region.Destroy method UI: Added DockPanel.AddDropdownRegion and .AddPopupRegion methods with various overloads. RTE: Added IRuntimeEditor.StopCoroutine RTE: Added IWindowManager Confirmation overloads UI: Added DialogManager .ShowComplexDialog UI: Added Dialog Alt button, Alt event and Alt action RTH: Changed RuntimeHitTester DefaultExecutionOrder to -89 RTB: Added support for Probuilder 4.4.0, 5.0.3 RTC: Added IRuntimeUndo.AddComponentWithRequirements RTH: Added MinOrthoSize, MaxOrthoSize properties to RuntimeSceneComponent RTE PeekMode: Dropdowns, add component panel, add component viewmodel RTE PeekMode: GameObjectName toggle + styling RTE PeekMode: ContextPanel using minimum distance = 50 when Empty Game Object selected UI: Fixed NullReferenceException when opening a menu control with more than 2 levels of depth RTE PeekMode: Added ComponentViewModel RTE PeekMode: Added ContextPanelViewModel RTE: Component Editor Icons added RTE: Added Default Component Editor Icon RTE: Added ComponentEditorSettings.ShowIcon and ComponentEditorSettings.Icon fields RTE: Added HeaderDescriptor.ShowIcon and HeaderDescriptor.Icon fields RTE: Added Component Editor Icon RTE: Implemented PeekMode context panel visibility and positioning RTB: Highlight AutoUV with different color in Manual UV Editor window RTB: Hidden position/rotation/scale handle axes if no faces selected in uv editing mode RTB: Fixed bug where ManualUVRenderer was not refreshed correctly on mesh editing to uv editing mode change RTB: Fixed bug where ManualUVRenderer was not refreshed correctly on vertex/edge/face mode change UI: Added SceneName parameter to MenuDefinitionAttribute (defines scene which menu applies to) RTE: Added PeekModeScene and PeekModeLayout RTE: Added BuiltInWindowNames RTE: Added LayoutExtension UI: Added LayoutInfo LayoutInfo.Horizontal(LayoutInfo top, LayoutInfo bottom, float ratio = 0.5f); UI: Added LayoutInfo LayoutInfo.Vertical(LayoutInfo left, LayoutInfo right, float ratio = 0.5f); UI: Added LayoutInfo LayoutInfo.Group(params LayoutInfo[] tabGroup); RTE: Added Transform IWindowManager.CreateWindow(string windowTypeName, out WindowDescriptor wd); RTE: Added Transform IWindowManager.CreateWindow(string windowTypeName, out WindowDescriptor wd, out bool isDialog); RTE: Added LayoutInfo IWindowManager.CreateLayoutInfo(Transform content, WindowDescriptor desc); RTH: Added SelectionPicker (corresponding code removed from BoxSelection and BoxSelectionRenderer) RTE: Replaced UnityEvent HideInInspector with NonSerialized attribute RTE: Added ReplaceSceneViewAndViewModelExample RTE: Added ability to overrided views RTE: Added SceneViewModelOverride example RTE: Added ability to override view models RTSL: Added support for objects with subassets imported from asset bundles. RTB: Material palette view tooltips added RTE: Added LocalizedTooltip RTC: SetCursor if m_currentCursorType != cursorType. CursorHelper.SetCursor return value changed from void to bool. RTE: ImportFileDialog replaced RTE: Fixed TimelineControl key already exists exceptions when adding row with ColumnCount = 1 RTE: AnimationSelectPropertiesDialog replaced RTH: Fixed SceneGizmo.DoSceneGizmo UI: DockPanel.RootRegion.FrameImage.enabled = false RTE: AnimationView replaced RTE: add BubbleUpPointerExit only if IsTouchSupported == true RTT: TerrainEditor instantiated by TerrainView OnEditorSelectionChanged RTT: store selected layer index. RTSL: Fixed compatibility with 2.11 - 2.26 files RTB: ManualUVEditorView, ManualUVSceneComponent, ManualUVRenderer fixed to work with Universal and HD RP RTSL: Updated PersistentSprite class to save textures which are not mapped. RTE: Replaced SaveAssetsDialog RTE: Replaced SaveFileDialog RTE: Replaced OpenFileDialog RTE: ProjectTreeViewModel select assets folder when selected folder removed RTE: ProjectTreeViewModel.SelectedItem accepts items for which CanDisplay returns true RTH: Added SelectionMode { UseColliders - default, UseRenderers, UseRenderersBeforeColliders }. RTT: Removed ProjectItemView from LayerListBoxItem.prefab UI: VirtualizingTreeViewItem.ItemPresenter.Label Overflow set to Ellipsis RTE: Added bool ShowLayers = true RTE: Added GameObjectEditorSettings RTE: ZipConstants.DefaultCodePage = System.Text.Encoding.UTF8.CodePage; RTE: Added 'select' parameter to public static void AddGameObjectToScene(this IRTE editor, GameObject go, bool select = true) method RTC: Added ImputLowForRDP.cs RTH: #pragma target 3.5 removed from OutlineBlur, OutlinePrepass, OutlineCompomosite RTE: private string[] m_hiddenValues added to EnumEditor RTE: virtual modifer added to ComponentEditor.BuildEditor and .OnExpanded methods RTE: bool? IsExpandedByDefault added to ComponentEditorSettings (used to calculate defaultValue in IsComponentExpanded getter) RTE: Replaced ImportAssetsDialog RTE: Replaced SelectAssetsDialog RTE: Renderers with isPartOfStaticBatch == true excluded from BoxSelection RTE: Using Screen.currentResolution.width instead of Display.main.systemWidth RTE: BaseGizmoInput DefaultExecution order changed to -59 RTE: BaseGizmo public virtual Reset method RTE: Replaced ToolsPanel RTE: Replaced SettingsDialog RTE: Fixed Default Layout procedure RTE: Added RectTool text outline RTE: Added HierarchicalDataView RTE: Implemented HierarchicalDataViewModel common drag & drop handling RTE: Replaced ProjectView RTE: Fixed VirtualizingTreeView CanBeParent, CanReparent flags behaviour RTE: Added ability to disable foreground layer in Universal RP (If disabled, then the windows with the camera should not go to the floating mode). RTE: Added m_depthMaskOffset field to DepthMaskingBehaviour (presumably fixes window depth masking bug on MacOS?) RTE: Using the default UI shader from Unity 2020 #if UNITY_2019 (fixes incorrect transparency of the ui in windows placed above the scene) RTSL: GetUOAssembliesAndTypes moved to ReflectionUtils.cs RTSL: UnityWeld excluded from assemblies array in CodeGen.GetUOAssembliesAndTypes and EditorsMapWindow.GetUOAssembliesAndTypes RTE: Replaced SelectObjectDialog RTE: Replaced SelectColorDialog RTE: Added IWindowManager.CreateDialogWindow overload without preferredWidth, preferredHeight parameters RTE: Replaced ManageProjectsDialog RTSL: ProjectInfo .Name, .LastWriteTime fields replaced with properties RTE: canResize = true param added to IWindowManager.Dialog methods RTE: canResize = true param added to Workspace.Dialog methods RTE: Replaced SaveSceneDialog RTE: Added DialogBinding RTE: OneWayPropertyBindingSlim and TwoWayPropertyBindingSlim added to ControlBinding RTSL: ProjectItem .Name, .Ext, .Children, .Parent fields replaced with properties RTE: Added missing functionality to write gameobject name changes to undo stack. RTE: Activated, Deactivated events added to RuntimeWindow RTE: AddComponentControl moved from InspectorView to GameObjectEditor RTE: Replaced InspectorView RTE: Ability to override Inspector selection. RTH: Added BoundingSphereRadius property to RuntimeSceneComponent RTE: Added RuntimeGameWindow RTE: Replaced SceneView RTE: Replaced ConsoleView RTE: Replaced HierarchyView RTSL: Added .Load_Async method with correct Task return type. RTSL: IProjectAsync .DeleteFolderAsync, .DeleteAsync don't throw an exception if ProjectItem doesn't exist RTE: View, ViewBinding added UI: Added PrefabIndex to MenuItemInfo UI: Replaced Menu m_menuItemPrefab with m_menuItemPrefabs RTE: Fixed Strong and EditorsMap classes (Universal Windows Platform) UI: Added VirtualizingTreeViewBinding .ItemClick, .ItemHold, .ItemDoubleClick, .ItemExpanded, .ItemCollapsed, .ItemDragEnter, .ItemDragExit events UI: Added VirtualizingTreeViewBinding .Target property UI: VirtualizingItemsControl .ItemClick event no longer occurs after ItemDoubleClick operation. UI: VirtualizingItemsControl .ItemClick event no longer occurs during a drag-and-drop operation. UI: Added VirtualizingTreeViewBinding DragItems, DropTargets UI: Added VirtualizingTreeViewBinding Drag&Drop Unity Events UI: Added ControlBinding, EventBindingSlim RTE: Added Project LockAsync WebGL implementation UI: VirtualizingListBox binding added UI: VirtualizingListBox added UI: VirtualizingScroller continuous mode added RTC: Added .Name property to ExposeToEditor. RTE: Added BuiltInWindows component added to Runtime Editor prefab. RTE: Added WindowManager.m_useLegacyBuiltInWindows = false. RTE: Added View prefabs, ViewModels and ViewModelTests. RTE: Existing view and dialog prefabs moved to Battlehub\\RTEditor\\Content\\Runtime\\RTEditor\\Prefabs\\Legacy. RTE: Existing views and dialogs moved to Battlehub\\RTEditor\\Runtime\\RTEditor\\Legacy. UI: MenuItem quick fix for InputSystem and mouse support RTE: InputSystem 1.0.1 package added RTE: WindowManager will call Editor.ActivateWindow only if ActiveWorkspace.ActivateWindow returns true; RTE: Workspace .ActivateWindow method fixed. Allow to activate window only in case if m_isTabDragInProgress == false; UI: Region .Insert method fixed. Turn on the new tab first or else Unity's UI.Toggle.Set() won't let us turn off the tab that was previously active. UI: Tab m_toggle.interactable = false; this will prevent the Toggle event from firing twice. RTE: Added HierarchyViewModel, HierarchyView prefab RTE: Deprecated prefabs from RTEditor\\Content\\Runtime\\Prefabs\\View and Dialog folders RTE: Deprecated AboutDialog, AssetLibraryImportDialog, AssetLibrarySelectDialog, ImportFileDialog, InputDialog, OpenFileDialog, ProjectsDialog, SaveAssetsDialog, SelectColorDialog, SelectObjectDialog, SettingsDialog RTE: Deprecated ProjectFolderView, ProjectFolderViewImpl, ProjectItemView, ProjectTreeViewImpl, ProjectView, ProjectViewImpl RTE: Deprecated SceneView, SceneViewImpl, GameView, HierarchyView, HierarchyViewImpl, InspectorView, ConsoleView, ToolsPanel RTE: Scene cursor cannot be changed when popup is displayed. RTE: Removed DragField from RangeEditor and RangeIntEditor prefabs. RTE: URP, HDRP UIForeground transparency fix for unity 2019. UI: Added IHierarchicalData interface. UI: Added INotifyHierarchicalDataChanged interface. UI: Added VirtualizingTreeViewBinding editor. UI: VirtualizingTreeViewBinding added. RTE: Added UnityWeld.dll. ####RTE 2.25 - Sept 30, 2020 Project structure: reorganized to support unity package manager Inspector: ability to select and edit multiple game objects and components. Inspector: layers editor. Inspector: layer mask editor. Inspector: culling mask added to camera component editor. Inspector: add component button keyboard navigation. Inspector: ability to configure visibility of buttons. Inspector: support for components with RequireComponent attribute. Hierarchy: search field added. Hierarchy: ability to override HierarchyView. Project: search field added. Project: ability to duplicate folders. Project: ability to override ProjectFolderView. Project: ability to override ProjectTreeView. Scene: ability to focus all active in hierarchy game objects with renderers. Scene: select objects on mouse button up. Scene: ability to select objects without collider. Scene: new box selection mode - pixel perfect depth test. Scene: auto save layout. DockPanel: Region.ClassAllTabs method added. DockPanel: variable tab size support. DockPanel: LayoutInfo must be created using IWindowManager.CreateLayoutInfo method. Theming: ability to set and update theme at runtime. Settings: dialog added. ProBuilder: uv unwrapping window. ProBuilder: uv stitch tool. ProBuilder: smooth groups editor. Graphics: HD Render Pipeline Support (Beta). Graphics: Universal Render Pipeline Support. Graphics: GL is not used anymore and replaced with CommandBuffer. RTSL: k__BackingField and delegates are not visible in Persistent Classes Window anymore. RTSL: separate RuntimeTypeModel.dll for each build target. RTSL: generating link.xml to support IL2CPP scripting backend. RTSL: mesh, texture, audio data imported from asset bundle is not saved on disk anymore. RTSL: save & load time and memory consumption reduced. RTSL: preventing the Editor from crashing when entering play mode with selected asset library. RTSL: support for different types of identifiers. RTSL: Autogenerated TypeMap.cs replace with TypeMapCreator RTSL: [CustomImplementation] class structure changed RTSL: IProject.ToID replaced with IProject.ToPersistentID method. RTSL: IProject.FromID replaced with IProject.FromPersistentID method. RTSL: IStorage interface replaced with IStrorage<> with PersistentObject<> params ####RTE 2.11 - Jan 30, 2020 Terrain details & trees editor ####RTE 2.10 - Dec 30, 2019 Terrain editor. ProBuilder integration. Animation editor. Runtime scripting. Localization. Transform Handles: Rect Tool. ####RTE 2.05 - April 30, 2019 Ability to change RTE UI Colors. UI.Text replaced with TextMeshProUGUI; File importers -> obj, png, jpg; VTV.SelectedIndex is set to -1 when Selected Item is null; Creating Primitives with Default-Material; ProjectItem.Get method fixed; Loading last project by default; Create project folder if there was no project before. Create camera and directional light by default. Dynamic resouces cleanup procedure fixed; Project Folder Drag & Drop bug fixed. ####RTE 2.04 - March 30, 2019 Rendering scene view and game view using RenderTexture and RawImage; LWRP support; Transform Handles: position handle freeze bug fixed. Transform Handles: correct model scale. Duplicate scene bug fixed. \"Open\" context menu item added. RuntimeWindow CanActivate property added. Ability to create tab groups. IOC container unloading bug fixed. ####RTE 2.03 - February 13, 2019 Configurable layout. Configurable tools panel. Configurable ui scale. Editor mappings are stored in RTEditor_Data folder and will not be overriden anymore. RTSL: TypeModel.dll correct import settings. RTSL: close progress bar in case of exception. Trasnform Handles: nullref exception fixed. RTE 2.02 - January 30, 2019 RTSL: codegen & persistent class storage fixed. RTSL: camera.pixelRect saved by default. RTSL: demo scene update. Transform Handles: demo scene update. RTE 2.01 - January 13, 2019 Set default layout nullref exception fixed. Transform Handles: prefabs added; Transform Handles: demo scene; ####RTE 2.00 - Dec 30, 2018 Runtime save-load subsystem. Ability create/manage projects. Project API. Assets & Asset bundles importer. Configurable layout (dock panels). Configurable main & context menu. New dialog windows and message boxes. Multiple viewports supported. Runtime handles touch support. Simple depency injection (IOC). Undo & Redo API. Object selection API. Object life-cycle events. Add components control. Console window. Lists and Hierarchies virtualization. ##About Hi, I am Vadym. I put a lot of effort into creating the Runtime Editor, but it was an interesting and rewarding experience. The first version of Runtime editor was released in June 2016 and was pretty simplistic. The current version is much more sophisticated but at the same time much more flexible and contains many useful features. If you have any questions or suggestions send them by email to Battlehub@outlook.com or join this support group. I hope you enjoy using the Runtime Editor and it will be useful."
  },
  "manual/gizmos.html": {
    "href": "manual/gizmos.html",
    "title": "| Example Unity documentation",
    "keywords": "#Gizmos Docs ##Overview Runtime Gizmos are the runtime 3D controls that are used to manipulate items in the scene. Unlike transform handles, gizmos does not modify the transformation of objects. Instead, they are used to modify colliders, bounding boxes and properties of light and audio sources. All gizmos, their base classes, rendering classes and shaders can be found in /Battlehub/RTEditor/Runtime/RTGizmos and /Battlehub/RTEditor/Content/Runtime/RTGizmos folders. Note In this section, Runtime Gizmos is simply called \"gizmos\". ##Getting Started Here are several simple steps to get started with gizmos: Create a Cube using Create->3D Object->Cube Select Cube. Add Assets BoxColliderGizmo component. Hit Play. Use mouse left-click + drag to resize Box Collider Gizmo. Note that Center and Size properties of Box Collider have been changed. ##Base Gizmo Source code of Base Gizmo can be found in Battlehub/RTEditor/Runtime/RTGizmos/BaseGizmo.cs. This is the base class of Box Gizmo, Sphere Gizmo, Capsule Gizmo and Cone Gizmo. Therefore all these gizmos have following settings: Grid Size  step size used in unit snapping mode (default: 1.0). Line Color  color of line. Handles Color  color of handle (small quad). Selection Color  color of selected handle. Enable Undo  if set to true then gizmo will write all changes to undo stack (default: true). Unit Snap Key  key switching gizmo to unit snapping mode. Target  target object reference; ##Box Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/BoxGizmo.cs. Base class for all gizmos that have box shape: Box Collider Gizmo Skinned Mesh Renderer Gizmo ##Sphere Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/SphereGizmo.cs. Base class for all gizmos that have sphere shape: Sphere Collider Gizmo Pointlight Gizmo Audio Source Gizmo Audio Reverb Zone Gizmo ##Capsule Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/CapsuleGizmo.cs. Base class for all gizmos that have capsule shape: Capsule Collider Gizmo ##Cone Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/ConeGizmo.cs. Base class for all gizmos that have cone shape: Spotlight Gizmo ##Box Collider Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/BoxColliderGizmo.cs. Box Collider Gizmo can be added to object with Box Collider: Create Game Object with Box Collider. Add Box Collider Gizmo component. ##Sphere Collider Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/SphereColliderGizmo.cs. Sphere Collider Gizmo can be added to object with Sphere Collider: Create Game Object with Sphere Collider. Add Sphere Collider Gizmo component. ##Capsule Collider Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/CapsuleColliderGizmo.cs. Capsule Collider Gizmo can be added to object with Capsule Collider: Create Game Object with Capsule Collider. Add Capsule Collider Gizmo component. ##Point Light Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/PointLightGizmo.cs. Point Light Gizmo can be added to Point Light: Create Point Light. Add LightGizmo component. ##Spot Light Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/SpotLightGizmo.cs. Spot Light Gizmo can be added to Spot Light: Create Spot Light. Add LightGizmo component. ##Directional Light Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/DirectionalLightGizmo.cs. Directional Light Gizmo can be added to Directional Light Create Directional Light. Add Light Gizmo component. ##Audio Source Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/AudioSourceGizmo.cs. Audio Source Gizmo can be added to Audio Source Create Audio Source. Add Audio Source Gizmo component. ##Audio Reverb Zone Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/AudioReverbZoneGizmo.cs. Same as AudioSouce Gizmo ##Skinned Mesh Renderer Gizmo Located in Battlehub/RTEditor/Runtime/RTGizmos/SkinnedMeshRendererGizmo.cs. Skinned Mesh Renderer Gizmo can be added to object with SkinnedMesh Create GameObject with SkinnedMeshRenderer. Add Skinned Mesh Renderer Gizmo component."
  },
  "manual/hdrp-support.html": {
    "href": "manual/hdrp-support.html",
    "title": "| Example Unity documentation",
    "keywords": "#HD Render Pipeline Support Docs ##Overview The Runtime Editor supports different versions of HD Render Pipeline. ##Getting Started Unpack Assets/Battlehub/6 HDRP Support [Your version].unitypackage. Click Tools->Runtime Editor->Use built-in HD RenderPipelineAsset. Switch Color Space from Gamma to Linear. Create Runtime Editor using Tools->Runtime Editor->Create RTEditor (Optionally Tools->Runtime Editor->Create RTExtensions) Add HDRP support using Tools->Runtime Editor->Add HDRP support for RTEditor (Optionally Tools->Runtime Editor->Add HDRP support for RTExtensions) Hit Play Note Complete demo scene can be found in Assets/Battlehub/RTEditorHDRP/Demo Be sure to unpack Assets/Battlehub/2 RTEditor Demo Note For Transform Handles use Tools->Runtime Handles submenu"
  },
  "manual/infrastructure.html": {
    "href": "manual/infrastructure.html",
    "title": "| Example Unity documentation",
    "keywords": "#Common Infrastructure Docs ##Overview Common infrastructure classes and interfaces form core api of runtime editor. Among other there are selection, object lifecycle, tools, undo-redo and drag&drop API's. ##Expose To Editor Add /Battlehub/RTEditor/Runtime/RTCommon/ExposeToEditor component to any Game Object you want to make available for selection and editing. UnityEvents: Selected Event raised when object added to Runtime Selection. Unselected Event raised when object removed from Runtime Selection. Fields & Properties: AddColliders  add colliders to enable selection? (default: true). Bounds Object  reference to the GameObject which will be used to calculate bounds. Custom Bounds  used if BoundsType == Custom. Bounds Type: * Mesh  MeshFilter.mesh.bounds will be used to calculate bounds. * SkinnedMesh  SkinnedMeshRenderer.mesh.bounds to calculate bounds. * Sprite - SpriteRenderer.sprite.bounds will be used to calculate bounds. * RectTransform CalculateRelativeRectTransformBounds method will be used to calculate bounds. * Custom  user defined bounds. * Any  any of the above. ##Event methods Event methods are called for all scripts of game objects with the Expose To Editor component attached. Note RuntimeAwake, RuntimeStart, OnRuntimeDestroy, OnRuntimeActivate, OnRuntimeDeactivate are called in play mode only. See IsPlaying property of IRTE interface using UnityEngine; public class ScriptEventsExample : MonoBehaviour { private void OnRuntimeEditorOpened() { Debug.Log(\"Editor Opened\"); } private void OnRuntimeEditorClosed() { Debug.Log(\"Editor Closed\"); } private void RuntimeAwake() { Debug.Log(\"Awake in play mode\"); } private void RuntimeStart() { Debug.Log(\"Start in play mode\"); } private void OnRuntimeDestroy() { Debug.Log(\"Destroy in play mode\"); } private void OnRuntimeActivate() { Debug.Log(\"Game View activated\"); } private void OnRuntimeDeactivate() { Debug.Log(\"Game View deactivated\"); } } ##IOC /Battlehub/RTEditor/Runtime/RTCommon/IOC is a simple IoC container implementation. Methods: static T Resolve<T>() - resolve dependency of type 'T' static void Register<T>(Func<T> func) - register construction function. static void Register<T>(T instance) - register instance. static void Unregister<T>(Func<T> func) - unregister construction function. static void Register<T>(T instance) - unregister instance. Example 1: using UnityEngine; using Battlehub.RTCommon; public interface IDependency { } public class Dependency : MonoBehaviour, IDependency { void Awake() { IOC.Register<IDependency>(this); } void OnDestroy() { IOC.Unregister<IDependency>(this); } } public class User : MonoBehaviour { void Start() { IDependency dependency = IOC.Resolve<IDependency>(); } } Example 2: using UnityEngine; using Battlehub.RTCommon; [DefaultExecutionOrder(-1)] public class Registrar : MonoBehaviour { void Awake() { IOC.Register<IDependency>(() => { GameObject go = new GameObject(); return go.AddComponent<Dependency>(); }); } private void OnDestroy() { IOC.Unregister<IDependency>(); } } public interface IDependency { } public class Dependency : MonoBehaviour, IDependency { } public class User : MonoBehaviour { void Awake() { IDependency dependency = IOC.Resolve<IDependency>(); } } ##IRTE interface Core editor functions and APIs are accessible through IRTE interface. This interface defined in /Battlehub/RTEditor/Runtime/RTCommon/RTEBase.cs Properties: CameraLayerSettings CameraLayerSettings { get; } - layers used by RTE. IInput Input { get; } - low level input. IRuntimeSelection Selection { get; } - selection functionality. IRuntimeUndo Undo { get; } - undo redo functionality. RuntimeTools Tools { get; } - tools functionality. CursorHelper CursorHelper { get; } - cursor helper. IRuntimeObjects Object { get; } - object lifecycle events. IDragDrop DragDrop { get; } - drag and drop functions. bool IsOpened { get; set; } - is editor opened? bool IsBusy { get; set; } - is editor busy? blocks user input. bool IsPlaymodeStateChanging { get; } - is editor either in play mode, or about to switch to it? bool IsPlaying { get; set; } - is editor currently in play mode? bool IsApplicationPaused { get; } - is application paused? Transform Root { get; } - editor root transform. RuntimeWindow ActiveWindow { get; } - currently active window. RuntimeWindow[] Windows { get; } - all registered windows. Methods: void ActivateWindow(RuntimeWindow window); - active window and associated RTE Components will receive user input. void RegisterCreatedObjects(GameObject[] go); - register created game objects to undo stack. void Duplicate(GameObject[] go); - duplicate objects and register created duplicates to undo stack. void Delete(GameObject[] go); - delete game objects and register this operation to undo stack. Events: RTEEvent PlaymodeStateChanging - raised before play mode change. RTEEvent PlaymodeStateChanged - raised when play mode state changed. RTEEvent ActiveWindowChanged - raised when window activated. RTEEvent<RuntimeWindow> WindowRegistered - raised when window registered. RTEEvent<RuntimeWindow> WindowUnregistered - raised when window unregistered. RTEEvent IsOpenedChanged - raised when IsOpened property changed. Here is how to get reference to IRTE: using UnityEngine; using Battlehub.RTCommon; public class GetIRTE : MonoBehaviour { void Awake() { IRTE editor = IOC.Resolve<IRTE>(); } } Open example: using UnityEngine; using Battlehub.RTCommon; public class OpenExample : MonoBehaviour { void Start() { IRTE rte = IOC.Resolve<IRTE>(); rte.IsOpened = true; } } Play example: using UnityEngine; using Battlehub.RTCommon; public class PlayExample : MonoBehaviour { void Start() { IRTE rte = IOC.Resolve<IRTE>(); rte.IsPlaying = true; } } Lock user input example: using UnityEngine; using System.Collections; using Battlehub.RTCommon; public class BlockUserInput : MonoBehaviour { IRTE m_rte; void Start() { m_rte = IOC.Resolve<IRTE>(); StartCoroutine(DummyOperation()); } IEnumerator DummyOperation() { yield return new WaitWhile(() => m_rte.IsBusy); m_rte.IsBusy = true; Debug.Log(\"User input locked\"); yield return new WaitForSeconds(5); m_rte.IsBusy = false; Debug.Log(\"User input unlocked\"); } } ##Input Runtime editor, transform handles and gizmos are using IInput interface to access user input. Here is how to get reference to IInput: using UnityEngine; using Battlehub.RTCommon; public class GetIRTE : MonoBehaviour { void Awake() { IInput input = IOC.Resolve<IRTE>().Input; } } IInput has following methods: bool IsAnyKeyDown() float GetAxis(InputAxis axisType) bool GetKeyDown(KeyCode key) bool GetKeyUp(KeyCode key) bool GetKey(KeyCode key) Vector3 GetPointerXY(int pointer) bool GetPointerDown(int button) bool GetPointerUp(int button) bool GetPointer(int button) ##RTE Component /Battlehub/RTEditor/Runtime/RTCommon/RTEComponent is the base class for all transform handles and gizmos. It hold reference to runtime window and check if this window is in active state. ##Runtime Selection IRuntimeSelection interface defined in Assets/Battlehub/RTCommon/Scripts/RuntimeSelection.cs. Here is how subscribe to SelectionChanged event and select object: using UnityEngine; using Battlehub.RTCommon; public class SelectObjectBehaviour : MonoBehaviour { IRuntimeSelection m_selection; void Start() { m_selection = IOC.Resolve<IRTE>().Selection; m_selection.SelectionChanged += OnSelectionChanged; GameObject go = GameObject.CreatePrimitive(PrimitiveType.Capsule); go.AddComponent<ExposeToEditor>(); m_selection.activeObject = go; } void OnDestroy() { if (m_selection != null) { m_selection.SelectionChanged -= OnSelectionChanged; } } void OnSelectionChanged(Object[] unselectedObjects) { if (unselectedObjects != null) { for (int i = 0; i < unselectedObjects.Length; ++i) { Object unselected = unselectedObjects[i]; Debug.Log(unselected); } } if (m_selection.objects != null) { for (int i = 0; i < m_selection.objects.Length; ++i) { Object selected = m_selection.objects[i]; Debug.Log(selected); } } } } ##Runtime Objects IRuntimeObjects interface defined in /Battlehub/RTEditor/Runtime/RTCommon/RuntimeObjects.cs. It can be used to track lifecycle events of objects exposed to editor. Methods: IEnumerable<ExposeToEditor> Get(bool rootsOnly, bool useCache = true) - call this method to get exposed to editor objects. If rootsOnly parameter set to false it return all objects, otherwise it return objects without parent. If useCache parameter set to false, then full traversal of object tree will be used. Events: event ObjectEvent Awaked - see corresponding MonoBehaviour event. event ObjectEvent Started - see corresponding MonoBehaviour event. event ObjectEvent Enabled - see correspondingMonoBehaviour event. event ObjectEvent Disabled - see corresponding MonoBehaviour event. event ObjectEvent Destroyed - see corresponding MonoBehaviour event. event ObjectEvent Destroying - raised just before Destroyed event. event ObjectEvent MarkAsDestroyedChanged - raised when object marked as destroyed by undo&redo event ObjectEvent MarkAsDestroyedChanging - raised just before MarkAsDestroyedChanged event. event ObjectEvent TransformChanged - position, rotation or localScale changed. event ObjectParentChangedEvent ParentChanged - transform.parent changed. event ObjectEvent NameChanged - object name changed. event ObjectEvent<Component> ComponentAdded - raised when new component added. Example: using UnityEngine; using Battlehub.RTCommon; public class ListenAwakeEvent : MonoBehaviour { IRuntimeObjects m_object; void Start() { m_object = IOC.Resolve<IRTE>().Object; m_object.Awaked += OnObjectAwaked; GameObject go = new GameObject(); go.AddComponent<ExposeToEditor>(); } void OnDestroy() { if(m_object != null) { m_object.Awaked -= OnObjectAwaked; } } void OnObjectAwaked(ExposeToEditor obj) { Debug.Log(obj); } } ##Runtime Tools RuntimeTools class can be found in /Battlehub/RTEditor/Runtime/RTCommon/RuntimeObjects.cs. Properties: LockObject LockAxes - this object hold aggregated locking state of selected objects. UnityObject ActiveTool - reference to active transform handle or gizmo. Active means that user is currently interacting with it. RuntimeTool Current - The tool that is currently selected for the Scene View: None Move Rotate Scale View Rect Custom RuntimePivotMode PivotMode - Are we in Center or Pivot mode. RuntimePivotRotation PivotRotation - What's the rotation of the tool handle: Global Local If property change, corresponding event is raised: event RuntimeToolsEvent ToolChanged event RuntimeToolsEvent PivotRotationChanged event RuntimeToolsEvent PivotModeChanged event RuntimeToolsEvent LockAxesChanged Here is how to change current tool: using UnityEngine; using Battlehub.RTCommon; public class SwitchToolBehaviour : MonoBehaviour { void Start() { IRTE editor = IOC.Resolve<IRTE>(); editor.Tools.Current = RuntimeTool.Rotate; } } Here is how to lock axes for all selected objects: using UnityEngine; using Battlehub.RTCommon; public class LockAxesForAllObjects : MonoBehaviour { IRTE m_editor; void Start() { m_editor = IOC.Resolve<IRTE>(); m_editor.Selection.SelectionChanged += OnSelectionChanged; m_editor.Tools.ToolChanged += OnToolChanged; } void OnDestroy() { if(m_editor != null) { m_editor.Selection.SelectionChanged -= OnSelectionChanged; m_editor.Tools.ToolChanged -= OnToolChanged; } } void OnToolChanged() { Lock(); } void OnSelectionChanged(Object[] unselectedObjects) { Lock(); } static void Lock() { IRTE editor = IOC.Resolve<IRTE>(); editor.Tools.LockAxes = new LockObject { PositionY = true, RotationX = true, RotationZ = true }; } } ##Runtime Undo IRuntimeUndo interface defined in /Battlehub/RTEditor/Runtime/RTCommon/RuntimeUndo.cs. It is used to record changes, maintain undo/redo stack and perform undo and redo operations. Properties: bool Enabled { get; set; } - is undo & redo enabled? bool CanUndo { get; } - can undo? bool CanRedo { get; } - can redo? bool IsRecording { get; } - are we recording multiple changes? Methods: void BeginRecord() - begin record multiple changes. void EndRecord() - end record multiple changes. Record CreateRecord(UndoRedoCallback redoCallback, UndoRedoCallback undoCallback, PurgeCallback purgeCallback = null, EraseReferenceCallback eraseCallback = null) - generic create record method. void RegisterCreatedObjects(ExposeToEditor[] createdObjects) - register created objects. void DestroyObjects(ExposeToEditor[] destoryedObjects) - register destroy objects operation. void BeginRecordValue(object target, MemberInfo memberInfo) - begin record value. void EndRecordValue(object target, MemberInfo memberInfo) - end record value. void BeginRecordTransform(Transform target) - begin record transform. void EndRecordTransform(Transform target) - end record transform. void AddComponent(ExposeToEditor obj, Type type) - add component and push corresponding record to the stack. void DestroyComponent(Component destroy, MemberInfo[] memberInfo) - destroy component and push corresponding record to the stack. void Redo() - redo. void Undo() - undo. void Purge() - purge all records. All marked as destroyed objects will be destroyed. void Erase(object oldRef, object newRef) - replace oldRef with newRef for all records in stack. void Store() - create new stack and store current undo&redo stack. void Restore() - restore previously stored stack. Events: event RuntimeUndoEventHandler BeforeUndo - raised before undo operation. event RuntimeUndoEventHandler UndoCompleted - raised after undo operation. event RuntimeUndoEventHandler BeforeRedo - raised before redo operation. event RuntimeUndoEventHandler RedoCompleted - raised after redo operation. event RuntimeUndoEventHandler StateChanged - raised whenever one of the following operations performed: Store Restore Purge Here is how to record value and then undo changes: using UnityEngine; using System.Reflection; using Battlehub.RTCommon; using Battlehub.Utils; public class RecordValueThenUndoChanges : MonoBehaviour { IRuntimeUndo m_undo; [SerializeField] int m_value = 1; void Start() { m_undo = IOC.Resolve<IRTE>().Undo; m_undo.UndoCompleted += OnUndoCompleted; MemberInfo valueInfo = Strong.MemberInfo((RecordValueThenUndoChanges x) => x.m_value); m_undo.BeginRecordValue(this, valueInfo); m_value = 2; m_undo.EndRecordValue(this, valueInfo); m_undo.Undo(); } void OnDestroy() { if (m_undo != null) { m_undo.UndoCompleted -= OnUndoCompleted; } } void OnUndoCompleted() { Debug.Log(m_value); //1 } } ##Drag And Drop IDragDrop interface defined in /Battlehub/RTEditor/Runtime/RTCommon/DragDrop.cs. It is used as a common interface for all drag & drop operations. Properties: object[] DragObjects { get; } - objects being dragged. object Source { get; } - drag & drop operation source object. bool InProgress { get; } - is drag and drop in progress? Methods: void Reset() - cancel current drag & drop operation. void SetCursor(KnownCursor cursorType) - set cursor. KnownCursor.DropNotAllowed KnownCursor.DropAllowed void RaiseBeginDrag(object source, object[] dragItems, PointerEventData pointerEventData) - begin drag & drop. void RaiseDrag(PointerEventData eventData) - drag. void RaiseDrop(PointerEventData pointerEventData) - end drag & drop. Events: event DragDropEventHander BeginDrag - raised by RaiseBeginDrag method. event DragDropEventHander Drag - raised by RaiseDrag method. event DragDropEventHander Drop - raised by RaiseDrop method. In this example we will handle Drag Drop operation into console window: using Battlehub.RTCommon; using UnityEngine; using UnityEngine.EventSystems; public class ConsoleDragDropHandler : MonoBehaviour { IDragDrop m_dragDrop; RuntimeWindow m_target; void Start() { m_target = IOC.Resolve<IRTE>().GetWindow(RuntimeWindowType.Console); m_dragDrop = IOC.Resolve<IRTE>().DragDrop; m_dragDrop.Drop += OnDrop; } void OnDestroy() { if(m_dragDrop != null) { m_dragDrop.Drop -= OnDrop; } } void OnDrop(PointerEventData pointerEventData) { if(m_target != null && m_target.IsPointerOver) { Debug.Log(m_dragDrop.DragObjects[0]); } } } ##Runtime Window RuntimeWindow class can be found in /Battlehub/RTEditor/Runtime/RTCommon/RuntimeWindow.cs. If you want to extend Runtime Editor with new windows, then they must be inherited from Runtime Window class. Here is how to do it: using Battlehub.RTCommon; using Battlehub.Utils; using UnityEngine; using UnityEngine.EventSystems; public class CustomWindow : RuntimeWindow { protected override void AwakeOverride() { WindowType = RuntimeWindowType.Custom; base.AwakeOverride(); } protected override void OnDestroyOverride() { base.OnDestroyOverride(); } protected override void OnActivated() { base.OnActivated(); Debug.Log(\"On Custom Window Activated\"); } protected override void OnDeactivated() { base.OnDeactivated(); Debug.Log(\"On Custom Window Deactivated\"); } public override void DragEnter(object[] dragObjects, PointerEventData eventData) { base.DragEnter(dragObjects, eventData); Editor.DragDrop.SetCursor(KnownCursor.DropAllowed); Debug.Log(\"On Drag Enter\"); } public override void DragLeave(PointerEventData eventData) { base.DragLeave(eventData); Editor.DragDrop.SetCursor(KnownCursor.DropNotAllowed); Debug.Log(\"On Drag Leave\"); } public override void Drop(object[] dragObjects, PointerEventData eventData) { base.Drop(dragObjects, eventData); Debug.Log(\"On Drop\"); for(int i = 0; i < dragObjects.Length; ++i) { Debug.Log(dragObjects[i]); } } } Note For information on how to register custom window please proceed to -> this <- section"
  },
  "manual/menu-control.html": {
    "href": "manual/menu-control.html",
    "title": "| Example Unity documentation",
    "keywords": "#Menu Control Docs ##Overview The Menu control allows hierarchal organization of elements associated with commands. It can be used to implement main and context menu of an application. ##Getting Started Create Canvas Add MenuButton.prefab from /Battlehub/RTEditor/Content/Runtime/UIControls/Menu/ Prefabs to hierarchy. Add Menu.prefab from /Battlehub/RTEditor/Content/Runtime/UIControls/Menu/Prefabs to hierarchy Set Menu field of the Menu Button: Create Empty Game Object and name it Command Handler Create MenuCmdHandler script and add it to the Command Handler: using UnityEngine; using Battlehub.UIControls.MenuControl; public class MenuCmdHandler : MonoBehaviour { public void OnValidateCmd(MenuItemValidationArgs args) { Debug.Log(\"Validate Command: \" + args.Command); if(args.Command == \"Item Cmd\") { args.IsValid = false; } } public void OnCmd(string cmd) { Debug.Log(\"Run Cmd: \" + cmd); } } Set Action and Validate event handlers of each entry in Items array of the Menu: Hit Play, open the Menu and click Child Item. You should see following output: ##Menu Item Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/Menu/Prefabs/MenuItem.prefab Script: /Battlehub/RTEditor/Runtime/UIControls/Menu/MenuItem.cs Fields: Selection Color - highlighted color. Text Color - text color. Disabled Selection Color - highlighted color of disabled menu item. Disabled Text Color - text color of disabled menu item. Icon - image. Text - text. Expander - image visible if menu item has sub-menu. Selection - image visible when pointer is over menu item. ##Menu Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/Menu/Prefabs/Menu.prefab Script: /Battlehub/RTEditor/Runtime/UIControls/Menu/Menu.cs Fields: Items - array of Menu Item Info. Menu Item Prefab - reference to menu item prefab. Anchor - opened menu will be aligned with anchor. Panel - parent of menu items. Canvas Group - required to \"fade-in\" menu. Fade in speed - how much the alpha property changes per second. [Serializable] public class MenuItemInfo { public string Path; //path to menu item e.g. Create/3DObject/Cube public string Text; //menu item text public Sprite Icon; //menu item icon public string Command; //argument passed to Action event handler and Validate event handler public MenuItemEvent Action; //raised when menu item clicked public MenuItemValidationEvent Validate; //event raised when menu opened } ##Main Menu Button This button can be used to open menu. It has three states: normal, pointer over and focused. The transition to the focused state occurs when the menu is opened. The transition to the normal state occurs when the menu is closed. Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/Menu/Prefabs/MenuButton.prefab Script: /Battlehub/RTEditor/Runtime/UIControls/Menu/MenuButton.cs ##Context Menu Trigger This script opens the menu when you click the right mouse button. Script: Assets/Battelhub/UIControls/Menu/Scripts/ontextMenuTrigger.cs"
  },
  "manual/rendering.html": {
    "href": "manual/rendering.html",
    "title": "| Example Unity documentation",
    "keywords": "#Rendering Notes ##IRTECamera All transform handles and gizmos use IRTECamera interface in order to be rendered. Camera camera = Window.Camera; IRTEGraphics graphics = IOC.Resolve<IRTEGraphics>(); if(graphics != null) { IRTECamera rteCamera = graphics.GetOrCreateCamera(camera CameraEvent.AfterForwardAlpha); m_rteCamera.CommandBufferRefresh += OnCommandBufferRefresh; m_rteCamera.RefreshCommandBuffer(); } protected virtual void OnCommandBufferRefresh(IRTECamera camera) { CommandBuffer cmd = camera.CommandBuffer; //drawing method calls } ##Graphics Layer Camera This is camera created automatically to render gizmos and transform handles. Clear Flags of this camera is set to the Depth only and Culling Mask to Nothing. At the same time RuntimeGraphicsLayers 0-3 will be excluded from Culling Mask of scene camera. Note Runtime Editor use 9 layers [16-24]: for ui, for asset previews and for runtime graphics."
  },
  "manual/runtime-editor.html": {
    "href": "manual/runtime-editor.html",
    "title": "| Example Unity documentation",
    "keywords": "#Runtime Editor Docs ##Overview Runtime Editor is the set of scripts and prefabs which help you to create scene editor, game level editor or build your own modeling application. It supports drag & drop, undo & redo and selection api. To implement user interface and core functions runtime editor use transform-handles, gizmos, save load subsystem and three controls: menu, virtualizing tree view and dock panels. Out of the box it has seven Views: Scene View to manipulate objects in the scene. Hierarchy View to display and manipulate object tree. Project View to manage assets and scenes. Inspector View to display and edit object properties. Console View to display information, warnings and errors. Game View main game camera output. Animation View to create and edit the runtime animations. Add More... The Runtime Editor has many ready-to-use property and component editors and it is relatively easy to create new ones. \"Add Component\" drop-down button allows you to add components at runtime. There are also several important dialogs included: Save Scene Dialog. Object Picker. Color Picker. Asset Bundles and Libraries Importer. Manage Projects Dialog. ##Getting Started To get started with Runtime Editor do following: Create new scene and save it. Click Tools->Runtime Editor->Create RTEditor Click \"Yes\" when you see the dialog box asking you to add the Game View Camera script. Create several Game Objects and add Expose To Editor component. Click Tools->Runtime SaveLoad->Config->Build All Hit Play Examples: Note The materials in the sample scenes were converted to Universal Render Pipeline. Be sure to install the Battlehub/1 UniversalRP Support [Version] package before opening the samples. See Universal Render Pipeline Support Docs for details. Install Battlehub/1 Universal RP Support [Your Version] package Install Battlehub/RTEditor Demo package Click Tools->Runtime Editor->Use built-in RenderPipelineAsset, then click \"Yes\" Click Tools->Runtime Editor->Show me examples Open RTEditor scene. Delete Battlehub/RTSL_Data folder. Click Tools->Runtime SaveLoad->Config->Build All Hit Play Few more steps: Create Asset Library Launch runtime editor and click File->Import Assets. Select the built-in asset library created in step 1. Import assets. You will see the imported assets in the project window. Note Demo scene can be found in Assets/Battlehub/RTEditorDemo/Content/Runtime/RTEditor ##Main & Context Menu Runtime Editor use Menu control to implement main and context-menu. To extend main menu create static class with [MenuDefinition] attribute and add static methods with [MenuCommand] attribute. using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; [MenuDefinition] public static class MyMenu { /// add new command to exising menu [MenuCommand(\"MenuWindow/Create My Window\")] public static void CreateMyWindow() { Debug.Log(\"Create My Window\"); } /// add new command to new menu [MenuCommand(\"My Menu/My Submenu/My Command\")] public static void CreateMyMenu() { Debug.Log(\"Create My Menu\"); } /// disable menu item [MenuCommand(\"My Menu/My Submenu/My Command\", validate: true)] public static bool ValidateMyCommand() { Debug.Log(\"Disable My Command\"); return false; } /// replace existing menu item [MenuCommand(\"MenuFile/Close\")] public static void Close() { Debug.Log(\"Intercepted\"); IRuntimeEditor rte = IOC.Resolve<IRuntimeEditor>(); rte.Close(); } /// Hide existing menu item [MenuCommand(\"MenuHelp/About RTE\", hide: true)] public static void HideAbout() { } } To open context menu with custom commands do following: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; public static class MyContextMenu { public static void OpenContextMenu() { IContextMenu contextMenu = IOC.Resolve<IContextMenu>(); MenuItemInfo cmd1 = new MenuItemInfo { Path = \"My Command 1\" }; cmd1.Action = new MenuItemEvent(); cmd1.Action.AddListener((args) => { Debug.Log(\"Run My Command1\"); IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); Debug.Log(editor.Selection.activeGameObject); }); MenuItemInfo cmd2 = new MenuItemInfo { Path = \"My Command 2\" }; cmd2.Validate = new MenuItemValidationEvent(); cmd2.Action = new MenuItemEvent(); cmd2.Validate.AddListener((args) => { args.IsValid = false; }); cmd2.Action.AddListener((args) => { Debug.Log(\"Run My Command2\"); }); contextMenu.Open(new[] { cmd1, cmd2 }); } } Built-in context menu populated and opened from Assets/Battlehub/RTEditor/Runtime/RTEditor/ViewModels/ProjectFolderViewModel.cs and ProjectTreeViewModel.cs ##RTEDeps The main purpose of the Assets/Battlehub/RTEditor/Runtime/RTEditor/RTEDeps.cs class is to register various services into IOC: IResourcePreviewUtility - create preview for Game Object or asset. IWindowManager - manage build-in and custom windows. IContextMenu - create and show context menu. IRuntimeConsole - log messages cache. IRuntimeEditor - the main interface of the RuntimeEditor. ##IRuntimeEditor IRuntimeEditor inherits the IRTE interface and adds several important methods and events. using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class GetRuntimeEditor : MonoBehaviour { void Start() { IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); } } Events: event RTEEvent SceneLoading - fired before loading the scene. event RTEEvent SceneLoaded - fired after loading the scene. event RTEEvent SceneSaving - fired before saving the scene. event RTEEvent SceneSaved - fired before saving the scene. Methods: void NewScene(bool confirm = true) - create a new scene (show the confirmation dialog by default). void SaveScene() - save the current scene. If the scene is new, the save scene dialog will appear. void CreateWindow(string window) - call corresponding method of window manager. void CreateOrActivateWindow(string window) - this method creates a window only if it does not exist. ProjectAsyncOperation<AssetItem[]> CreatePrefab(ProjectItem folder, ExposeToEditor obj, bool? includeDeps = null) - create prefab with preview. ProjectAsyncOperation<AssetItem[]> SaveAssets(UnityObject[], Action<AssetItem[]>) - save assets. ProjectAsyncOperation<ProjectItem[]> DeleteAssets(ProjectItem[] projectItems) - delete assets. ProjectAsyncOperation<AssetItem> UpdatePreview(UnityObject obj) - update asset preview. Example: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.RTSL.Interface; using System.Threading.Tasks; using UnityEngine; public class IRuntimeEditorMethodsUsageExample : EditorExtension { protected override async void OnInit() { base.OnInit(); //Get runtime editor IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); IProjectAsync project = IOC.Resolve<IProjectAsync>(); while (!project.State.IsOpened) { await Task.Yield(); } //Create Prefabs folder ProjectItem[] folders = await project.CreateFoldersAsync(new[] { \"Prefabs\" }); //Create new object and hide it from hierarchy GameObject go = GameObject.CreatePrimitive(PrimitiveType.Sphere); go.hideFlags = HideFlags.HideAndDontSave; go.SetActive(false); //Create prefab with preview and destroy source object await editor.CreatePrefabAsync(folders[0], go.AddComponent<ExposeToEditor>(), true); Destroy(go); //Load prefab GameObject loadedGo = await project.Load_Async<GameObject>(\"Prefabs/Sphere\"); //... Make changes //Update preview await editor.UpdatePreviewAsync(loadedGo); //Save changes await editor.SaveAssetsAsync(new[] { loadedGo }); //Get corresponding project item ProjectItem projectItem = project.Utils.ToProjectItem(loadedGo); //Delete prefab and clear undo stack await editor.DeleteAssetsAsync(new[] { projectItem }); //Delete folders await project.DeleteAsync(folders); } } ##Window Manager Window Manager allows you to create complex windows, such as an inspector or scene, and simple dialogs, such as a message box or confirmation. The difference between dialog and window is rather subtle. The content of the dialog can be anything, and it can not be docked. To be considered as a window or dialog window, a Runtime Window component must be attached to the game object. When the runtime window is activated, the other windows are deactivated. The dialog cannot deactivate the window. Note Default windows and dialogs can be found in Assets/Battlehub/RTEditor/Content/Runtime/RTEditor/Prefabs Note Window Manager use dock panels control. Get window manager: using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class GetWindowManager : MonoBehaviour { void Start() { IWindowManager wm = IOC.Resolve<IWindowManager>(); } } Show message box: ```C# wm.MessageBox(\"Header\", \"Text\", (sender, args) => { Debug.Log(\"OK Click\"); }); ``` Show confirmation: ```C# wm.Confirmation(\"Header\", \"Text\", (sender, args) => { Debug.Log(\"Yes click\"); }, (sender, args) => { Debug.Log(\"No click\"); }, \"Yes\", \"No\"); ``` Activate window: ```C# wm.ActivateWindow(BuiltInWindowNames.Scene); ``` Create window: ```C# wm.CreateWindow(BuiltInWindowNames.Scene); ``` Create dialog window: ```C# IWindowManager wm = IOC.Resolve (); wm.CreateDialogWindow(BuiltInWindowNames.About, \"Header\", (sender, args) => { Debug.Log(\"OK\"); }, (sender, args) => { Debug.Log(\"Cancel\"); }); ``` Set default layout: ```C# IWindowManager wm = IOC.Resolve (); string persistentLayoutName = wm.DefaultPersistentLayoutName; if (wm.LayoutExist(persistentLayoutName)) { wm.DeleteLayout(persistentLayoutName); } wm.SetDefaultLayout(); ##How to: add custom window to Window Manager > [!NOTE] > For information on how to create custom window please navigate to this -> [this](infrastructure.md#runtime-window) <- section 1. Click Tools->Runtime Editor->Create Custom Window. ![Screenshot](~/resources/img/rteditor/window-manager/custom-window-menu.png) 2. Enter MyCustomWindow.prefab and click Save. 3. Enter MyNamespace namespace and click OK. 3. Add __RegisterMyCustomWindow__ component created in step 1. 4. Drag & Drop MyCustomWindow.prefab to Prefab field of RegisterMyCustomWindow script. 5. Click Play. 6. You should be able to open custom window using main menu. ![Screenshot](~/resources/img/rteditor/window-manager/custom-window-created.png) 7. Use [UnityWeld] (https://github.com/Real-Serious-Games/Unity-Weld). ##How to: override default layout To override default layout do following: 1. Create a script derived from LayoutExtension. 2. Override `GetLayoutInfo` method. 3. Create a new game object and add created script. 4. To prevent the game object from being destroyed by [Save & Load](save-load.md) add __RTSLIgnore__ component. ![Screenshot](~/resources/img/rteditor/window-manager/layout-override.png) ``` C# using Battlehub.UIControls.DockPanels; namespace Battlehub.RTEditor.Examples.Layout { /// <summary> /// Creates three colums layout (inspector, (scene, hierarchy)) /// </summary> public class ThreeColumsLayoutExample : LayoutExtension { protected override LayoutInfo GetLayoutInfo(IWindowManager wm) { LayoutInfo scene = wm.CreateLayoutInfo(BuiltInWindowNames.Scene); scene.IsHeaderVisible = true; LayoutInfo hierarchy = wm.CreateLayoutInfo(BuiltInWindowNames.Hierarchy); LayoutInfo inspector = wm.CreateLayoutInfo(BuiltInWindowNames.Inspector); //Defines a region divided into two equal parts (ratio 1 / 2) LayoutInfo sceneAndHierarchy = LayoutInfo.Horizontal(scene, hierarchy, ratio: 1/2.0f); //Defines a region divided into two parts //1/3 for the inspector and 2/3 for the scene and hierarchy) LayoutInfo layoutRoot = LayoutInfo.Horizontal(inspector, sceneAndHierarchy, ratio: 1/3.0f); return layoutRoot; } } } You should see following: ##How to: override scene parameters To override scene parameters do following: Create ScenesSetupExample script. Override Extend method and WindowTypeName property. Create a new game object and add created script. To prevent the game object from being destroyed by Save & Load add RTSLIgnore component. using Battlehub.RTCommon; using Battlehub.RTHandles; using UnityEngine; namespace Battlehub.RTEditor.Examples.SceneSetup { /// <summary> /// This extension initializes 2D scene window /// </summary> public class ScenesSetupExample : RuntimeWindowExtension { /// <summary> /// Type of window to be extended /// </summary> public override string WindowTypeName => BuiltInWindowNames.Scene; protected override void Extend(RuntimeWindow window) { //get a reference to the IRuntimeSceneComponent of the window IRuntimeSceneComponent sceneComponent = window.IOCContainer.Resolve<IRuntimeSceneComponent>(); //This is the point the camera looks at and orbiting around sceneComponent.Pivot = Vector3.zero; //Switch the scene component and scene camera to orthographic mode sceneComponent.IsOrthographic = true; //Disable scene gizmo sceneComponent.IsSceneGizmoEnabled = false; //Disable rotation sceneComponent.CanRotate = false; //Disable free move sceneComponent.CanFreeMove = false; //Prevent camera position changes when zooming in and out sceneComponent.ChangeOrthographicSizeOnly = true; //Set initial orthographic size sceneComponent.OrthographicSize = 5.0f; //Set camera position according to window.Args const float distance = 100; sceneComponent.CameraPosition = -Vector3.forward * distance; } } } ##How to: override tools panel To override tools panel do following: Create ToolsPanelOverride script. Create game object and add ToolsPanelOverride component. Set Tools Prefab field To prevent the game object from being destroyed by Save & Load add RTSLIgnore component. using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class ToolsPanelOverrideExample : EditorExtension { [SerializeField] private Transform m_toolsPrefab = null; protected override void OnEditorCreated(object obj) { OverrideTools(); } protected override void OnEditorExist() { OverrideTools(); IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); if (editor.IsOpened) { IWindowManager wm = IOC.Resolve<IWindowManager>(); if (m_toolsPrefab != null) { wm.SetTools(Instantiate(m_toolsPrefab)); } else { wm.SetTools(null); } } } private void OverrideTools() { IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.OverrideTools(m_toolsPrefab); } } You should see following: ##How to: override ui scale To override ui scale do following: Create UIScaleOverride script. Create game object and add UIScaleOverride component. Set desired Scale To prevent the game object from being destroyed by Save & Load add RTSLIgnore component. using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class UIScaleOverride : EditorExtension { [SerializeField] private float Scale = 2; protected override void OnEditorExist() { ISettingsComponent settings = IOC.Resolve<ISettingsComponent>(); settings.UIScale = Scale; } } Before: After: ##How to: change runtime editor colors RTE Appearance editor allows you to change colors of runtime editor. Reset Colors button will revert colors to default. Following resources must be modified also: To override ui colors programmatically do following: Create UIColorsOverride script. Create game object and add UIColorsOverride component. To prevent the game object from being destroyed by Save & Load add RTSLIgnore component. using Battlehub.RTCommon; using UnityEngine; namespace Battlehub.RTEditor.Demo { public class UIColorsOverride : EditorExtension { protected override void OnEditorExist() { ISettingsComponent settings = IOC.Resolve<ISettingsComponent>(); settings.SelectedThemeIndex = -1; RTEColors colors = new RTEColors(); colors.Primary = Color.red; IRTEAppearance appearance = IOC.Resolve<IRTEAppearance>(); appearance.Colors = colors; } } } ##File Importers File importers are used during file import procedure to convert external file format to format supported by Runtime Editor. For example .png images should be converted to UnityEngine.Texture2D before import. Note Unpack Battlehub/3 RTEditor Importer package FileBrowser with importers can be opened using File->Import From File menu item To write custom importer do following. Create new script and inherit your class from ProjectFileImporterAsync: using Battlehub.RTCommon; using Battlehub.RTSL.Interface; using System; using System.IO; using System.Threading; using System.Threading.Tasks; using UnityEngine; using UnityObject = UnityEngine.Object; namespace Battlehub.RTEditor { public class JpgImporterExample : ProjectFileImporterAsync { public override string FileExt { get { return \".jpg\"; } } public override string IconPath { get { return \"Importers/Jpg\"; } } public override Type TargetType { get { return typeof(Texture2D); } } public override async Task ImportAsync( string filePath, string targetPath, IProjectAsync project, CancellationToken cancelToken) { byte[] bytes = filePath.Contains(\"://\") ? await DownloadBytesAsync(filePath) : File.ReadAllBytes(filePath); Texture2D texture = new Texture2D(4, 4); try { if (texture.LoadImage(bytes, false)) { IResourcePreviewUtility previewUtility = IOC.Resolve<IResourcePreviewUtility>(); byte[] preview = previewUtility.CreatePreviewData(texture); using (await project.LockAsync()) { await project.SaveAsync(targetPath, texture, preview); } } else { throw new FileImporterException($\"Unable to load image {filePath}\"); } } catch (Exception e) { throw new FileImporterException(e.Message, e); } finally { UnityObject.Destroy(texture); } } } } Note Currently File Browser supported on Windows platform only ##Inspector View The main purpose of the inspector is to create different editors depending on the type of selected object and its components. Here is a general idea of what is happening: The user selects a Game Object, and the inspector creates a GameObject editor. The game object editor creates component editors. Each component editor creates property editors. Prefabs: InspectorView can be found in Assets/Battlehub/RTEditor/Content/Runtime/RTEditor/ Prefabs/Views folder, GameObject, Material and Component editors in Assets/Battlehub/RTEditor/Content/ Runtime/RTEditor/Prefabs/Editors, Property editors in Assets/Battlehub/RTEditor/Content/Runtime/RTEditor/Prefabs/ Editors/PropertyEditors. ##How To: Configure Editors To select the editors to be used by the inspector, click Tools->Runtime Editor->Configuration There are five sections in configuration window: Object Editors - select which editor to use for Game Object. Property Editors - select which editors to use for component properties. Material Editors - select which editors to use for materials Standard Component Editors  select which editors to use for standard components. Script Editors  select which editors to use for scripts. After you select and enable the desired component editors, click the Save Editors Map button ##How To: Select Component Properties To select the properties displayed by the component editor, you need to create a class and inherit it from ComponentDescriptorBase< > . After that, you need to implement the GetProperties method. It should return PropertyDescriptors for all properties that will be present in the component editor ui. Here is an example of TransformComponentDescriptor: using UnityEngine; using System.Reflection; using Battlehub.Utils; using Battlehub.RTCommon; namespace Battlehub.RTEditor { public class TransformComponentDescriptor : ComponentDescriptorBase<Transform> { public override object CreateConverter(ComponentEditor editor) { object[] converters = new object[editor.Components.Length]; Component[] components = editor.Components; for (int i = 0; i < components.Length; ++i) { Transform transform = (Transform)components[i]; if (transform != null) { converters[i] = new TransformPropertyConverter { ExposeToEditor = transform.GetComponent<ExposeToEditor>() }; } } return converters; } public override PropertyDescriptor[] GetProperties( ComponentEditor editor, object converter) { object[] converters = (object[])converter; MemberInfo position = Strong.PropertyInfo( (Transform x) => x.localPosition, \"localPosition\"); MemberInfo positionConverted = Strong.PropertyInfo( (TransformPropertyConverter x) => x.LocalPosition, \"LocalPosition\"); MemberInfo rotation = Strong.PropertyInfo( (Transform x) => x.localRotation, \"localRotation\"); MemberInfo rotationConverted = Strong.PropertyInfo( (TransformPropertyConverter x) => x.LocalEuler, \"LocalEulerAngles\"); MemberInfo scale = Strong.PropertyInfo( (Transform x) => x.localScale, \"localScale\"); MemberInfo scaleConverted = Strong.PropertyInfo( (TransformPropertyConverter x) => x.LocalScale, \"LocalScale\"); return new[] { new PropertyDescriptor( \"Position\",converters, positionConverted, position), new PropertyDescriptor( \"Rotation\", converters, rotationConverted, rotation), new PropertyDescriptor( \"Scale\", converters, scaleConverted, scale) }; } } } TransformPropertyConverter is used to convert a quaternion to Euler angles. This is needed for Vector3Editor to be used instead of QuaternionEditor. Note The remaining built-in component descriptors are in the Assets/Battlehub/RTEditor/Runtime/RTEditor/Editors/ComponentDescriptors folder. ##Resource Preview Utility The Resource Preview utility is used to create a preview of objects. This is how to use it: using Battlehub.RTCommon; using UnityEngine; using UnityEngine.UI; namespace Battlehub.RTEditor.Demo { public class CreatePreviewExample : MonoBehaviour { [SerializeField] private Image m_image = null; [SerializeField] private Object m_object = null; private Texture2D m_previewTexture; private Sprite m_previewSprite; private void Update() { if (Input.GetKeyDown(KeyCode.Space)) { IResourcePreviewUtility previewUtil = IOC.Resolve<IResourcePreviewUtility>(); if (m_previewTexture != null) { Destroy(m_previewTexture); } if (m_previewSprite != null) { Destroy(m_previewSprite); } if(previewUtil.CanCreatePreview(m_object)) { m_previewTexture = previewUtil.CreatePreview(m_object); m_previewSprite = Sprite.Create(m_previewTexture, new Rect(0, 0, m_previewTexture.width, m_previewTexture.height), new Vector2(0.5f, 0.5f)); m_image.sprite = m_previewSprite; } } } private void OnDestroy() { if (m_previewSprite != null) { Destroy(m_previewSprite); } if (m_previewTexture != null) { Destroy(m_previewTexture); } } } }"
  },
  "manual/save-load.html": {
    "href": "manual/save-load.html",
    "title": "| Example Unity documentation",
    "keywords": "#Save Load Docs ##Overview The Runtime Save & Load (RTSL) subsystem is required for saving and managing scenes, assets and projects at runtime and consists of three main parts: Persistent Classes - this part allows you to choose what to serialize and generate persistent classes for serialization. Asset Libraries - this part allows you to create and manage assets, as well as provide information to the RTSL to identify these assets. Project - this part provides api to interact with RTSL. Note RTSL use protobuf.net for serialization. ##Getting Started After importing RTSL you will see the configuration window: After clicking \"Build All\", several folders will be created under /Battlehub/RTSL_Data Scripts for serializable persistent classes. Custom Implementation for user defined persistent classes. Mappings for mappings between types that must be stored and serializable persistent types. Libraries for asset libraries and shader profiles. Note RTSLTypeModel.dll contains protobuf-net type model. Due to unity scripting restrictions, runtime type model need to be pre-complied before using at runtime. Create a new scene. Drag and Drop Assets/Battlehub/RTEditorDemo/Content/Runtime/RTEditor/DemoGame/ Prefabs/Game.prefab to hierarchy. Click Tools->Runtime SaveLoad->Update Libraries Click Tools->Runtime SaveLoad->Create RTSL Create RTSLExample script and add it to the Game Object created at previous step. Hit play. Save scene using 'M' key. Load scene using 'L' key. using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; public class RTSLExample : MonoBehaviour { IProject m_project; IEnumerator Start() { m_project = IOC.Resolve<IProject>(); yield return m_project.OpenProject(\"My Project\"); yield return m_project.CreateFolder(\"Scenes/Demo\"); } IEnumerator SaveScene() { ProjectAsyncOperation ao = m_project.Save(\"Scenes/Demo/Scene\", SceneManager.GetActiveScene()); yield return ao; if(ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } IEnumerator LoadScene() { ProjectAsyncOperation ao = m_project.Load<Scene>(\"Scenes/Demo/Scene\"); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } void Update() { if (Input.GetKeyDown(KeyCode.M)) { StartCoroutine(SaveScene()); } if (Input.GetKeyDown(KeyCode.L)) { if (m_project.Exist<Scene>(\"Scenes/Demo/Scene\")) { StartCoroutine(LoadScene()); } } } } Saved scene can be found in PersistentDataPath/My Project/Assets/Scenes/Demo folder. Note Only several persistent classes enabled by default. Use Persistent Classes Editor Window to enable more. Note Demo scene can be found in Assets/Battlehub/RTEditorDemo/Content/Runtime/RTSL folder. ##Persistent Classes Persistent Class is a class derived from Persistent Surrogate and has the [ProtoContract] attribute . The main purpose of persistent classes is to give you complete control over what to save and how to save, without having to use reflection and without writing a lot of boilerplate code. To open persistent classes editor, click Tools->Runtime SaveLoad->Persistent Classes->Edit. Here is the persistent classes editor window: This window allows you: Search for types you want to save. Select properties you want to save. Generate C# code of persistent classes. After clicking the \"Create Persistent Classes\" button the following will occur: Persistent classes will be created in Assets/Battlehub/RTSL_Data/Scripts/PersistentClasses. ![Screenshot](~/resources/img/save-load/persistent-classes/persistent-classes-folder.png) <br/><br/> The editor window state will be saved in Assets/Battlehub/RTSL_Data/Mappings/Editor. ![Screenshot](~/resources/img/save-load/persistent-classes/mappings-folder.png) <br/><br/> Custom Implementations will be created in .../RTSL_Data/Scripts/CustomImplementation. ![Screenshot](~/resources/img/save-load/persistent-classes/custom-implementation-folder.png) <br/><br/> Note To ensure forward compatibility of saved files, never delete the ClassMappingStorage and SurrogatesMappingsStorage prefabs !!! ##How To: Create Custom Persistent Class In some cases, it is not possible to obtain all data to be saved using public properties and fields. For example, some data can only be retrieved using methods. If you need to write your own code to save and load data, follow these steps: Open Persistent Classes Editor. Find and select required type. Select \"Custom Implementation\" ![Screenshot](~/resources/img/save-load/persistent-classes/create-custom-implementation.png) <br/><br/> Click Create Persistent Classes button. Click Edit Custom Implementation button. ![Screenshot](~/resources/img/save-load/persistent-classes/edit-custom-implementation.png) <br/><br/> You should see following: #if !RTSL_MAINTENANCE using Battlehub.RTSL; namespace UnityEngine.Battlehub.SL2 { [CustomImplementation] public partial class PersistentJoint<TID> { /* public override void ReadFrom(object obj) { base.ReadFrom(obj); } public override object WriteTo(object obj) { return base.WriteTo(obj); } public override void GetDeps(GetDepsContext<TID> context) { base.GetDeps(context); } public override void GetDepsFrom(object obj, GetDepsFromContext context) { base.GetDepsFrom(obj, context); } */ } } #endif There are four methods that can be implemented: void ReadFrom(object obj) - called before serialization. Read the data from obj and save it to the fields of the persistent object. object WriteTo(object obj) - called after deserialization. Write stored data to obj. void GetDeps(GetDepsContext<TID> context) - return IDs of dependencies. void GetDepsFrom(object obj, GetDepsFromContext context) - get dependencies from obj. Implementation of PersistentJoint may look like this: #if !RTSL_MAINTENANCE using Battlehub.RTSL; namespace UnityEngine.Battlehub.SL2 { [CustomImplementation] public partial class PersistentJoint<TID> { [ProtoBuf.ProtoMember(1)] private TID m_connectedBody; [ProtoBuf.ProtoMember(2)] private PersistentVector3<TID> m_anchor; //..... more fields public override void ReadFrom(object obj) { base.ReadFrom(obj); Joint joint = (Joint)obj; if (joint == null) { return; } m_connectedBody = ToID(joint.connectedBody); m_anchor = joint.anchor; //... read other fields } public override object WriteTo(object obj) { obj = base.WriteTo(obj); Joint joint = (Joint)obj; if (joint == null) { return obj; } joint.connectedBody = FromID<Rigidbody>(m_connectedBody); joint.anchor = m_anchor; //... write other fields return joint; } public override void GetDeps(GetDepsContext<TID> context) { base.GetDeps(context); AddDep(m_connectedBody, context); //... get other dependencies } public override void GetDepsFrom(object obj, GetDepsFromContext context) { base.GetDepsFrom(obj, context); Joint joint = (Joint)obj; if (joint == null) { return; } AddDep(joint.connectedBody, context); //... get other dependencies } } } #endif Note Click Tools-> Runtime SaveLoad->Config->Build All every time you finish making changes to the persistent classes and are ready to build your application. ##Asset Library Game objects in any scene refer assets such as materials, meshes, textures, etc. Identifiers of these assets obtained using GetInstanceID() method do not remain constant and can change. Asset libraries, in contrast, are used to store unique asset identifiers that never change. There are two special asset libraries: Built-in asset library - contains Unity build-in assets. Scene asset library - contains assets referenced by scene Game Objects. Both libraries created automatically by clicking Tools->Runtime SaveLoad->Update Libraries Note Scene asset libraries are referenced using the scene name. This means that scenes must have unique names. Note Click Tools->Runtime SaveLoad->Update Libraries each time you have finished making changes to the scene and are ready to run the application. ##How To: Create Asset Library If the built-in asset library and scene dependency library are not sufficient, and the new resources must be Resource.Loaded at runtime, you can create a new asset library by clicking Create -> Runtime SaveLoad -> Runtime Asset Library in the context menu. Note An asset library must be created inside the Resources folder. Use drag & drop to add assets to asset library Note One asset library can contain no more than 65535 assets. If you change hierarchy of one or more prefabs, you will be asked to synchronize the assets library. Do it by clicking Synchronize button. ##Project Item & Asset Item Project Items are used to create tree structures representing the project tree. [ProtoContract] [ProtoInclude(1, typeof(AssetItem))] public class ProjectItem { [ProtoMember(2)] public long ItemID; [ProtoMember(3)] public Guid ItemGUID; public string Name; public string Ext; public ProjectItem Parent; public List<ProjectItem> Children; // ... Asset Items are meta representations of assets in a project. They are stored in *.rtmeta files. [ProtoContract] public class AssetItem : ProjectItem { public event EventHandler PreviewDataChanged; [ProtoMember(1)] public Guid TypeGuid; [ProtoMember(2)] public PrefabPart[] Parts; [ProtoMember(3)] public long[] Dependencies; [ProtoMember(4, IsRequired = true)] public long CustomDataOffset = -1; [ProtoMember(5)] public Guid[] DependenciesGuids; private Preview m_preview; public Preview Preview { get { return m_preview; } set { if (m_preview != value) { m_preview = value; if (PreviewDataChanged != null) { PreviewDataChanged(this, EventArgs.Empty); } } } } public override bool IsFolder { get { return false; } } } ##Project IProject is the main interface of the RTSL library. Here is how to access it: using Battlehub.RTCommon; using Battlehub.RTSL.Interface; void Awake() { IProject project = IOC.Resolve<IProject>(); } Open project: ``` C# using System.Collections; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { IProject project = IOC.Resolve (); yield return project.OpenProject(\"My Project\"); } <br/> Close project: ``` C# m_project.CloseProject(); Delete project: ``` C# yield return project.DeleteProject(\"My Project\"); ``` Create folder: ``` C# yield return project.CreateFolder(\"My Scenes\"); ``` Delete folder: ``` C# yield return project.DeleteFolder(\"My Scenes\"); ``` Save scene: ``` C# using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { //... ProjectAsyncOperation ao = project.Save(\"My Scenes/Scene 1\", SceneManager.GetActiveScene()); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } <br/> Load scene: ``` C# using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { //... ProjectAsyncOperation ao = project.Load<Scene>(\"My Scenes/Scene 1\"); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } Delete scene: ``` C# yield return project.Delete (\"My Scenes/Scene 1\"); ``` Find objects of type: ``` C# foreach(string scene in project.Find (\"Scene 1\")) { Debug.Log(scene); } <br/> Create Prefab: ``` C# GameObject primitive = GameObject.CreatePrimitive(PrimitiveType.Capsule); yield return project.Save(\"Capsule\", primitive); Destroy(primitive); Load and instantiate Prefab: ``` C# ProjectAsyncOperation ao = project.Load (\"Capsule\"); yield return ao; if(!ao.Error.HasError) { Instantiate(ao.Result[0]); } <br/> Import all assets from asset bundle: ``` C# //get names of asset bundles from Assets/StreamingAssets folder. ProjectAsyncOperation<string[]> ao = project.GetAssetBundles(); yield return ao; //load ImportItems from first asset bundle ProjectAsyncOperation<ProjectItem> loadAo = project.LoadImportItems(ao.Result[0], false); yield return loadAo; if (!loadAo.Error.HasError) { //create previews here... //then unload asset bundle assets project.UnloadImportItems(loadAo.Result); //import all yield return project.Import(loadAo.Result.Flatten(true).OfType<ImportItem>().ToArray()); } //log all asset items in project foreach(string path in project.Find<object>(string.Empty, true)) { Debug.Log(path); }"
  },
  "manual/transform-handles.html": {
    "href": "manual/transform-handles.html",
    "title": "| Example Unity documentation",
    "keywords": "#Transform Handles Docs ##Overview Runtime Transform Handles are the runtime 3D controls that are used to manipulate items in the scene. There three built-in transform tools to position, rotate and scale object via transform component. Another special built-in tool - the rect tool allows you to move and change scale of game objects. Supplementary controls such as scene gizmo, selection gizmo and grid allows to change viewing angle and projection mode, identify selected objects and orientate in scene space. Another important components: selection component, scene component and handles component allows to select objects, navigate in scene and change transform handles appearance. Scripts, prefabs and example scenes for transform handles can be found in Assets/Battlehub/RTHandles folder. Note Runtime Transform Handles are simply referred as transform handles through this text Here is how transform handles and components rendered in the game view: All in one: ##Getting Started Here are four simple steps to get started with transform handles: Create transform handles using Tools->Runtime Handles->Create. Create and select Game Object. Enable object editing with Tools->Runtime Handles->Enable Editing. Hit play. After clicking on the game object in the game view you should see the following: Following actions available by default: Action Input Select Left-click Move (Pan) Hold middle mouse button, then drag Flythrough Click and hold the right mouse button. Move around using mouse and WSAD keys. Orbit Hold Alt+left-click, then drag Zoom Use the scroll wheel Undo Shift + Z (Ctrl + Z in player) Redo Shift + Y (Ctrl + Y in player) Note Example scenes can be found in Assets/Battlehub/RTEditorDemo/Content/Runtime/RTHandles ##Base Handle This is the base class for position, rotation, scale transform handles. Therefore all transform handles have following settings: Window - reference to the window. Interaction with transform handle allowed only in case referenced window is active. HighlightOnHover - bool value. If true then transform handles will be highlighted on pointer over. Set it to false if touch input is used. (default: true) Appearance - reference to the runtime handles component. Various visual settings. Model - reference to the prefab with BaseHandle model component attached. If Model is set then default rendering procedure will be disabled and prefab instance will be rendered instead. Targets - array of transforms to be modified by transform handle. GridSize - float value used in unit-snapping mode. By default Unit-snapping mode is activated with 'Shift' key. BeforeDrag - event raised before transform handle drag. Drag - event raised each frame during drag and drop operation. Drop - event raised when drag and drop operation completed. ##Position Handle To create a position handle, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/PositionHandle component. The colors and scale of the transform handles can be adjusted using Runtime Handles Component, and the proportions of individual parts such as lines and arrows can be adjusted using the Position Handle Model script attached to PositionHandleModel.prefab. To change the proportions of the position handle, modify Assets/Battlehub/RTEditor/Content/Runtime/RTHandles/Prefabs/ PositionHandleModel.prefab and add a reference to it using Model field of the Position Handle. Position Handle Model script has following fields: Radius - thickness of the line (default: 0,01). Length - lenght of the line (default: 1). Arrow Radius - radius of the arrow (default 0,075). Arrow Length - lenght of the arrow (default 0,2). Quad Length - size of xy, xz and yz quads (default 0,2). Adjustments example: ##Rotation Handle To create a rotation handle, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/RotationHandle component. The colors and scale of the transform handles can be adjusted using Runtime Handles Component, and the proportions of individual parts can be adjusted using the Rotation Handle Model script attached to RotationHandleModel.prefab. To change the proportions of the rotation handle, modify Assets/Battlehub/RTEditor/Content/Runtime/RTHandles/Prefabs/RotationHandleModel.prefab and add a reference to it using Model field of the Rotation Handle. Rotation Handle Model script has following fields: Minor Radius - line thickness (default: 0,0075). Major Radius - x-axis, y-axis, z-axis, inner circle radius (default: 1). Outer Radius - outer circle radius (default: 1,11). Adjustments example: ##Scale Handle To create a scale handle, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/ScaleHandle component. The colors and scale of the transform handles can be adjusted using Runtime Handles Component, and the proportions of individual parts can be adjusted using the Scale Handle Model script attached to ScaleHandleModel.prefab. To change the proportions of the scale handle, modify Assets/Battlehub/RTEditor/Content/Runtime/RTHandles/Prefabs/ScaleHandleModel.prefab and add a reference to it using Model field of the Scale Handle. Scale Handle Model script has following fields: Radius - line thickness (default: 0,01). Length - line length (default: 1). Arrow Radius - cap size (default: 0,05). Adjustments example: ##Rect Tool To create a rect tool, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/RectTool component. Set Targets field. The colors and scale of the rect tool can be adjusted using Runtime Handles Component. ##Locking Axes The Assets/Battlehub/RTEditor/Runtime/RTCommon/LockAxes component prevents the modification of certain transformations with the position, rotation or scale handles. Attach it to selectable Game Object and choose axes you want to lock. ##Scene Gizmo To create a scene gizmo, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/SceneGizmo component. Scene gizmo script has following fields: Window - reference to the window. Interaction with scene gizmo allowed only in case referenced window is active. Btn Projection - UGUI button to switch between orthographic and perspective projection (default: None). Pivot - transformation of the object around which the camera rotates. Size - scene gizmo rect size (default: 96,96). Pivot Point - scene gizmo rect pivot point (default: 1,0). Anchor - scene gizmo rect anchor (default: 1,0). Appearance - reference to the runtime handles component. Various visual settings. Orientation Changing - event fires when camera rotation and position are about to be changed. Orientation Changed - event fires when camera rotation and position are changed. Projection Changed - event fires when camera projection changed. ##Grid To create a grid, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/SceneGrid component. To change color of the grid use Grid Color field of runtime handles component. ##Runtime Handles Component Use this script to change appearance of transform handles: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/RuntimeHandlesComponent component Runtime Handles Component script has following fields: Colors - transform handles, scene gizmo, selection gizmo and grid colors. Handle Scale - transform handles scale (default: 1). Scene Gizmo Scale - scale of the scene gizmo (default: 1). Selection Margin - scale of clickable area around transform handle axes (default: 1). Invert Z Axis - invert position handle z-axis (default: false). Position Handle Arrows Only - hide xy, yz and xz quads (default: false). ##Runtime Selection Component This is the implementation of default selection behavior. To enable default selection behavior: Create a new Game Object. Add Assets/Battlehub/RTHandles/Scripts/RuntimeSelectionComponent. Choose objects you want to make selectable and click Tools->Runtime Handles->Enable Editing. Alternatively add Assets/Battlehub/RTEditor/Runtime/RTCommon/ExposeToEditor. To visualize selection add OutlineManager to object with Runtime Selection Component. Following actions defined in Assets/Battlehub/RTHandles/Scripts/Input/RuntimeSelectionInput : Action Input Select Left-click Select multiple Hold Shift + left-click (Ctrl + left-click in player) Select all Hold Shift + A (Ctrl + A in player) Runtime Selection Component script has following fields: Window - window reference. Position Handle - position handle reference. Rotation Handle - rotation handle reference. Scale Handle - scale handle reference. Rect Tool - rect tool reference. Box Selection - box selection reference. Grid - scene grid reference. To switch between transform handles using Q W E R T keys, do the following : Add Assets/Battlehub/RTEditor/Runtime/RTHandles/Input/RuntimeToolsInput component. Note If you wish to switch between transform handles programmatically proceed to -> this <- section. Note If you wish to change selection programmatically proceed to -> this <- section. ##Box Selection To create a Box Selection, do the following: Create a new Game Object. Add Assets/Battlehub/RTEditor/Runtime/RTHandles/BoxSelection component. Note Game Objects without ExposeToEditor component are invisible to Box Selection. Note Box Selection use Runtime Selection API to store selected objects. Box Selection has following fields: Window - reference to the window. Graphics - sprite which is used to render box selection. Use Camera Space - use camera space for rendering (true) or screen space (false) (default:true) Box Selection Method - box selection method: Vertex - use MeshFilter.sharedMesh.vertices (default); Loose Fitting - use renderer bounds and collider (default); Bounds Center - use bounds center; Transform Center - use transform center; Use following code to filter objects selected using Box Selection: using Battlehub.RTHandles; using UnityEngine; //In this example objects with name \"Capsule\" are filtered out public class FilteringBehaviour : MonoBehaviour { [SerializeField] private BoxSelection m_boxSelection; private void Start() { m_boxSelection.Filtering += OnFiltering; } private void OnDestroy() { if (m_boxSelection != null) { m_boxSelection.Filtering -= OnFiltering; } } private void OnFiltering(object sender, FilteringArgs e) { if (e.Object.name == \"Capsule\") { e.Cancel = true; } } } ##Runtime Scene Component Runtime Scene Component extends Runtime Selection Component and enables mouse orbiting, movement and zoom. To create a Runtime Scene Component, do the following: Create a new Game Object Add Assets/Battlehub/RTEditor/Runtime/RTHandles/RuntimeSelectionComponent. Runtime Scene Component has following fields: View Texture - cursor which is visible during mouse orbiting. Move Texture - cursor which is visible during movement. Free Move Texture - cursor which is visibile in flythrough mode. Scene Gizmo - reference to the Scene Gizmo. Actions defined in Battlehub/RTEditor/Runtime/RTHandles/Input/RuntimeSceneInput : Action Input Focus Press F Snap To Grid Press Shift + G (Ctrl + G in player) Move (Pan) Hold middle or right mouse button, then drag Flythrough Click and hold the right mouse button. Move around using mouse and WSAD keys. Orbit Hold Alt+left-click, then drag Zoom Use the scroll wheel"
  },
  "manual/urp-support.html": {
    "href": "manual/urp-support.html",
    "title": "| Example Unity documentation",
    "keywords": "#Universal Render Pipeline Support Docs ##Overview The Runtime Editor supports different versions of Unversal Render Pipeline. ##Getting Started Unpack Assets/Battlehub/1 UniversalRP Support [Your version].unitypackage. Click Tools->Runtime Editor->Use built-in RenderPipelineAsset. Switch Color Space from Gamma to Linear. Create Runtime Editor using Tools->Runtime Editor->Create RTEditor (Optionally Tools->Runtime Editor->Create RTExtensions) Add Universal RP support using Tools->Runtime Editor->Add URP support for RTEditor (Optionally Tools->Runtime Editor->Add URP support for RTExtensions) Hit Play Note Complete demo scene can be found in Assets/Battlehub/RTEditorURP/Demo Be sure to unpack Assets/Battlehub/2 RTEditor Demo Note For Transform Handles use Tools->Runtime Handles submenu"
  },
  "manual/vtv.html": {
    "href": "manual/vtv.html",
    "title": "| Example Unity documentation",
    "keywords": "#Virtualizing TreeView Docs ##Overview The Virtualizing Tree View is a control that displays a hierarchical data. Virtualzing Tree View implements drag & drop, data binding and selection functions. It is highly customizable and can be used to display large collections of data (1000+ items). ##Getting Started Create Canvas. Add VirtualizingTreeView.prefab from /Battlehub/RTEditor/Content/Runtime/UIControls/VirtualizingTreeView/Prefabs to hierarchy. Create GettingStarted.cs script and add it to VirtualizingTreeView Game Object. Hit Play. //GetStarted.cs using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using Battlehub.UIControls; //Example of hierarchical data item public class ExampleDataItem { public string Name; //... additional fields here ...// public ExampleDataItem Parent; public List<ExampleDataItem> Children; public ExampleDataItem(string name) { Name = name; Children = new List<ExampleDataItem>(); } public override string ToString() { return Name; } } public class GetStarted : MonoBehaviour { private VirtualizingTreeView m_treeView; //root level data items private List<ExampleDataItem> m_items; void Start() { m_treeView = GetComponent<VirtualizingTreeView>(); //This event fired for each item that becomes visible m_treeView.ItemDataBinding += OnItemDataBinding; //This event is fired for each expanded item m_treeView.ItemExpanding += OnItemExpanding; //This event is triggered for each item after drag & drop m_treeView.ItemDrop += OnItemDrop; //Create data items m_items = new List<ExampleDataItem>(); for(int i = 0; i < 1000; ++i) { m_items.Add(new ExampleDataItem(\"Data Item \" + i)); } //Populate tree view with data items m_treeView.Items = m_items; } void OnDestroy() { if(m_treeView != null) { m_treeView.ItemDataBinding -= OnItemDataBinding; m_treeView.ItemExpanding -= OnItemExpanding; m_treeView.ItemDrop -= OnItemDrop; } } void OnItemDataBinding(object sender, VirtualizingTreeViewItemDataBindingArgs e) { ExampleDataItem item = (ExampleDataItem)e.Item; //Get the controls from ItemsPresenter and copy the data into them. Text text = e.ItemPresenter.GetComponentInChildren<Text>(true); text.text = item.Name; Image icon = e.ItemPresenter.GetComponentsInChildren<Image>()[4]; icon.sprite = Resources.Load<Sprite>(\"IconNew\"); //Notify the tree of the presence of child data items. e.HasChildren = item.Children.Count > 0; } void OnItemExpanding(object sender, VirtualizingItemExpandingArgs e) { ExampleDataItem item = (ExampleDataItem)e.Item; //Return children to the tree view e.Children = item.Children; } void OnItemDrop(object sender, ItemDropArgs args) { if (args.DropTarget == null) { return; } //Handle ItemDrop event using standard handler. m_treeView.ItemDropStdHandler<ExampleDataItem>(args, (item) => item.Parent, (item, parent) => item.Parent = parent, (item, parent) => ChildrenOf(parent).IndexOf(item), (item, parent) => ChildrenOf(parent).Remove(item), (item, parent, i) => ChildrenOf(parent).Insert(i, item)); } List<ExampleDataItem> ChildrenOf(ExampleDataItem parent) { if (parent == null) { return m_items; } return parent.Children; } } You should see scrollable tree view with data items and drag & drop support: Note Full demo can be found in Assets/Battlehub/RTEditorDemo/Content/Runtime/UIControls/VirtualizingTreeView folder ##Virtualizing Scroll Rect This class reuse \"ui containers\" to efficiently represent large data collections. UI containers are created only for a small visible part of data. VirtualizingScrollRect.cs can be found in Assets/Battlehub/RTEditor/Runtime/UIControls/VirtualizingTreeView folder. Events: event DataBindAction ItemDataBinding - raised when new portion of data become visible . Fields: Container Prefab - prefab, which is used to create instances of ui containers for data items. Virtual Content - parent of ui containers. Properties: IList Items { get; set; } - gets or sets list of data items. int ItemsCount{ get; } - gets the number of data items. int Index { get; set; } - gets or sets index of first visible data item. int VisibleItemsCount { get; } - gets the number of currently visible data items. Methods: bool IsParentOf(Transform child) - returns true if the Scroll Rect is the parent of the Transform. void InsertItem(int index, object item, bool raiseDataBindingEvent = true) - insert data item. void RemoveItems(int[] indices, bool raiseItemDataBindingEvent = true) - remove data items. RectTransform GetContainer(object obj) - returns the ui container for data item. RectTransform FirstContainer() - returns the first visible ui container. RectTransform LastContainer() - returns the last visible ui container. void ForEachContainer(System.Action<RectTransform> action) - run action for each ui container. void SetNextSibling(object sibling, object nextSibling) - reorder data items and ui containers. void SetPrevSibling(object sibling, object prevSibling) - reorder data items and ui containers. ##Virtualizing Items Control This class implements drag and drop, insert, delete, reorder functions and triggers many useful events. It also serves as the base class for controls, such as listbox and treeview. Implementation can be found in Assets/Battlehub/RTEditor/Runtime/UIControls/VirtualizingTreeView folder. Events: event EventHandler<ItemArgs> ItemBeginDrag - raised on begin drag. event EventHandler<ItemDropCancelArgs> ItemBeginDrop - raised on item drop. event EventHandler<ItemDropCancelArgs> ItemDragEnter - occurs when the pointer enters a new drop target. event EventHandler ItemDragExit - raised when pointer leaves drop area. event EventHandler<ItemArgs> ItemDrag - fired while dragging an item. event EventHandler<ItemDropArgs> ItemDrop - fired after item dropped. event EventHandler<ItemArgs> ItemEndDrag - raised when drag & drop operation completed. event EventHandler<SelectionChangedArgs> SelectionChanged - occurs when the selection is changed. event EventHandler<ItemArgs> ItemDoubleClick - triggered after double clicking on an item. event EventHandler<ItemArgs> ItemClick - triggered after clicking on an item. event EventHandler<ItemsCancelArgs> ItemsRemoving - triggered before removing items. event EventHandler<ItemsRemovedArgs> ItemsRemoved - triggered after removing items. event EventHandler IsFocusedChanged - raised when IsFocused value changed. event EventHandler Submit - on submit. event EventHandler Cancel - on cancel. event EventHandler<PointerEventArgs> Click - triggered after clicking on the tree view. event EventHandler<PointerEventArgs> PointerEnter - occurs when the pointer enters the tree view. event EventHandler<PointerEventArgs> PointerExit - occurs when the pointer leaves the tree view. event EventHandler<TDataBindingArgs> ItemDataBinding - occurs when a new ui container is created or an update is required. event EventHandler<TDataBindingArgs> ItemBeginEdit - occurs when the ui container enters edit mode, and the EditorPresenter becomes visible. event EventHandler<TDataBindingArgs> ItemEndEdit- occurs when the ui container exit edit mode, and the ItemsPresenter becomes visible. Fields: bool SelectOnPointerUp - select item on pointer up (default: false). bool CanUnselectAll - can the user unselect all items? If set to false then at least one item has to be selected (default: true). bool CanSelectAll - can the user select all items? (default:true). bool CanEdit - can the user edit items? (default: true). bool CanRemove - can the user remove items? (default: true). bool CanDrag - is drag & drop allowed? (default:true). bool CanReorder - Is the reordering of items allowed? (default: true). float ScrollSpeed - scrolling sensitivity. Properties: object DropTarget { get; } - get currently active drop target. object[] DragItems { get; } - get items that are currently dragging. ItemDropAction DropAction { get; } - get current drop action: None, SetLastChild, SetPrevSilbing, SetNextSibling. int SelectedItemsCount { get; } - get selected data items count. IEnumerable SelectedItems { get; set; } - get or set selected data items. object SelectedItem { get; set; } - get or set selected data item. int SelectedIndex { get; set; } - get or set index of selected data item. IEnumerable Items { get; set; } - data source. Methods: int IndexOf(object obj) - get the index of the data item. void SetIndex(object obj, int newIndex) - set index of data item. VirtualizingItemContainer GetItemContainer(object item) - get the visible ui container. ItemContainerData GetItemContainerData(object item) - get the state of the ui container. ItemContainerData Add(object item) - add data item. ItemContainerData Insert(int index, object item) - insert data item. void Remove(object item) - remove data item. void SetNextSibling(object sibling, object nextSibling) - reorder data items and ui containers. void SetPrevSibling(object sibling, object prevSibling) - reorder data items and ui containers. ##Virtualizing Drop Marker The Virtualizing Drop Marker is used to highlight the drop location of the item. Virtualizing Drop Marker can be in one of the states defined in the ItemDropAction enum. public enum ItemDropAction { None, SetLastChild, SetPrevSibling, SetNextSibling } ##Virtualizing Tree View Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/VirtualizingTreeView/Prefabs/VirtualizingTreeView. Script: /Battlehub/RTEditor/Runtime/UIControls/VirtualizingTreeView/VirtualizingTreeView.cs. Base Class: Virtualizing Items Control Events: event EventHandler<VirtualizingItemExpandingArgs> ItemExpanding - triggered before the parent item expands. event EventHandler<VirtualizingItemCollapsedArgs> ItemCollapsed - triggered after folding the parent item. Fields: bool SelectOnPointerUp - select item on pointer up (default: false). bool CanUnselectAll - If set to false then at least one item has to be selected (default: true). bool CanSelectAll - can the user select all items? (default:true). bool CanEdit - can the user edit items? (default: true). bool CanRemove - can the user remove items? (default: true). bool CanDrag - is drag & drop allowed? (default:true). bool CanReorder - Is the reordering of items allowed? (default: true). bool CanReparent - Is parent change allowed? (default: true). float ScrollSpeed - scrolling sensitivity. Methods: void AddChild(object parent, object item) - add child item. void RemoveChild(object parent, object item) - remove child item. bool Expand(object item) - expand item fails and returns false if the element is not visible and is a descendant of the collapsed parent). void ExpandTo<T>(T item, Func<T,T> getParent) - expand all ancestors. void ExpandChildren<T>(T item, Func<T, IEnumerable> getChildren) - expand all descendants. void ExpandAll(T item, Func<T,T> getParent, Func<T, IEnumerable> getChildren) - calls ExpandTo, then ExpandChildren. void Collapse(object item) - collapse item. Examples: //Select all root items private VirtualizingTreeView m_treeView; void Start() { m_treeView = GetComponent<VirtualizingTreeView>(); //..Initialization and data binding... m_treeView.SelectionChanged += OnSelectionChanged; m_treeView.SelectedItems = m_treeView.Items; } void OnDestroy() { if(m_treeView != null) { m_treeView.SelectionChanged -= OnSelectionChanged; } } private void OnSelectionChanged(object sender, SelectionChangedArgs e) { if(e.NewItems != null) { foreach(object item in e.NewItems) { Debug.Log(item); } } } //Add children and expand selected items public void Add() { foreach (ExampleDataItem parent in m_treeView.SelectedItems) { ExampleDataItem item = new ExampleDataItem(\"New Item\"); parent.Children.Add(item); item.Parent = parent; m_treeView.AddChild(parent, item); m_treeView.Expand(parent); } } //Collapse selected items public void Collapse() { foreach (DataItem selectedItem in TreeView.SelectedItems) { TreeView.Collapse(selectedItem); } } //Expand selected items and their children public void Expand() { foreach(ExampleDataItem selectedItem in m_treeView.SelectedItems) { m_treeView.ExpandAll(selectedItem, item => item.Parent, item => item.Children); } } //Remove selected items public void Remove() { foreach (ExampleDataItem selectedItem in m_treeView.SelectedItems.OfType<object>().ToArray()) { m_treeView.RemoveChild(selectedItem.Parent, selectedItem); } } Note ExampleDataItem defined in Getting Started section. ##Virtualizing Tree View Item Structure: Prefab: /Battlehub/RTEditor/Content/Runtime/UIControls/VirtualizingTreeView/Prefabs/VirtualizingTreeViewItem. Script: /Battlehub/RTEditor/Runtime/UIControls/VirtualizingTreeView/VirtualizingTreeViewItem.cs. Fields: ItemPresenter - normal mode ui. EditorPresenter - edit mode ui. ItemLayout - reference to LayoutElement."
  }
}